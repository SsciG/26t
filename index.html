<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>T26 Endless Runner</title>
    <style>
        html, body {
                width: 100%;
                height: 100%;
                margin: 0;
                overflow: hidden;
                overscroll-behavior: none;
                overflow-x: hidden;
                }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
            overflow: hidden;
            background: radial-gradient(circle at top, #151b2f 0%, #05070c 45%, #020308 100%);
            color: #fff;
        }

        #gameContainer {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            padding: 0;
            overflow: hidden;
        }

        /* Game Frame - wraps canvas and matches its dimensions exactly */
        #gameFrame {
            position: relative;
            width: fit-content;
            height: fit-content;
        }

        /* Vignette around canvas (now on gameFrame, not gameContainer) */
        #gameFrame::after {
            content: "";
            position: absolute;
            inset: 0;
            pointer-events: none;
            box-shadow:
                0 0 0 1px rgba(80, 250, 240, 0.08),
                0 0 140px 80px rgba(0, 0, 0, 0.95) inset;
            border-radius: 18px;
        }

        #gameCanvas {
            display: block;
            background: radial-gradient(circle at 50% 15%, #28354e 0%, #060813 55%, #020308 100%);
            border-radius: 18px;
            box-shadow:
                0 26px 80px rgba(0,0,0,.85),
                0 0 0 1px rgba(120, 220, 210, 0.24);
            touch-action: none;
            max-width: 100%;
             max-height: 100%;
        }

        /* ================= HUD ================= */
        #ui {
            position: absolute;
            top: 26px;
            left: 50%;
            transform: translateX(-50%);
            display: inline-flex;
            align-items: center;
            gap: 18px;
            padding: 8px 20px;
            background: radial-gradient(circle at top left,
                        rgba(18, 40, 60, 0.85),
                        rgba(6, 14, 26, 0.96));
            border-radius: 999px;
            border: 1px solid rgba(111, 255, 233, 0.25);
            box-shadow:
                0 14px 32px rgba(0, 0, 0, 0.65),
                0 0 25px rgba(0, 255, 224, 0.06);
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
            z-index: 20;
        }

        .hud-pill {
            display: inline-flex;
            flex-direction: column;
            align-items: flex-start;
            padding-right: 10px;
        }

        .hud-label {
            font-size: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            color: rgba(220, 230, 245, 0.65);
        }

        .hud-value-row {
            display: inline-flex;
            align-items: baseline;
            gap: 4px;
        }

        .hud-value {
            font-size: 18px;
            font-weight: 600;
            color: #f8fafc;
        }

        .hud-unit {
            font-size: 11px;
            text-transform: uppercase;
            color: rgba(210, 225, 240, 0.7);
        }

       
        #systemControls {
            position: absolute;
            right: 34px;
            bottom: 34px;
            display: flex;
            gap: 12px;
            z-index: 30;
            opacity: 0.85;
            transition: opacity 0.2s ease, transform 0.2s ease;
        }

        #systemControls:hover {
            opacity: 1;
            transform: translateY(-2px);
        }

        #audioToggle, #fullscreenToggle {
            position: relative;
            min-width: 94px;
            padding: 6px 14px;
            border-radius: 999px;
            border: 1px solid rgba(111, 255, 233, 0.28);
            background: radial-gradient(circle at top,
                        rgba(19, 50, 61, 0.9),
                        rgba(4, 12, 20, 0.95));
            color: rgba(235, 245, 255, 0.85);
            font-size: 11px;
            letter-spacing: 1.5px;
            text-transform: uppercase;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            box-shadow:
                0 12px 26px rgba(0,0,0,.8),
                0 0 14px rgba(0, 255, 224, 0.25);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            transition: transform 0.16s ease, box-shadow 0.16s ease, background 0.2s ease;
        }

        #audioToggle:hover, #fullscreenToggle:hover {
            transform: translateY(-1px);
            box-shadow:
                0 16px 32px rgba(0, 0, 0, 0.9),
                0 0 18px rgba(0, 255, 224, 0.45);
        }

        .primary-btn {
            padding: 16px 40px;
            border-radius: 50px;
            border: none;
            background: radial-gradient(circle at top,
                        rgba(255, 149, 0, 0.9),
                        rgba(255, 87, 34, 0.95));
            color: #ffffff;
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            cursor: pointer;
            box-shadow:
                0 8px 20px rgba(255, 87, 34, 0.4),
                0 2px 8px rgba(0, 0, 0, 0.3);
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            flex: 1;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow:
                0 12px 28px rgba(255, 87, 34, 0.6),
                0 4px 12px rgba(0, 0, 0, 0.4);
        }


        .withdraw-btn {
            flex: 1;

            padding: 12px 48px;  

            border-radius: 50px;
            border: none;
            height: 52px;          
            padding: 0 48px;    

            font-size: 12px;
            font-weight: 600;
            letter-spacing: 2px;
            text-transform: uppercase;

            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;

            background: linear-gradient(135deg, #5f5f5f, #3e3e3e);
            color: rgba(220, 220, 220, 0.75);
            cursor: not-allowed;

            box-shadow: 0 16px 40px rgba(0,0,0,.85);

            transition: transform 0.16s ease, box-shadow 0.16s ease, filter 0.16s ease;
        }



        .withdraw-btn:hover {
                transform: translateY(-1px);

                filter: brightness(1.05);

                box-shadow:
                    inset 0 1px 0 rgba(255,255,255,0.08),
                    0 16px 34px rgba(0,0,0,.85);
            }

        /* ================= Overlays ================= */
        .overlay-card {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            max-width: 420px;
            width: 92vw;
            padding: 34px 34px 30px;
            border-radius: 24px;
            background:
                radial-gradient(circle at top left,
                    rgba(255, 149, 0, 0.15),
                    transparent 55%),
                radial-gradient(circle at bottom right,
                    rgba(255, 87, 34, 0.15),
                    transparent 60%),
                linear-gradient(135deg,
                    rgba(20, 15, 10, 0.96),
                    rgba(30, 20, 10, 0.98));
            border: 1px solid rgba(255, 149, 0, 0.35);
            box-shadow:
                0 40px 120px rgba(0, 0, 0, 0.95),
                0 0 0 1px rgba(255, 87, 34, 0.6),
                0 0 80px rgba(255, 149, 0, 0.4);
            backdrop-filter: blur(24px);
            -webkit-backdrop-filter: blur(24px);
            text-align: center;
            z-index: 40;
        }

        #startScreen {
            top: 52%;
            transform: translate(-50%, -50%);
        }

        .logo-container {
            margin-bottom: 20px;
        }

        .logo-container img {
            width: 180px;
            height: auto;
            filter:
                drop-shadow(0 12px 30px rgba(15, 23, 42, 0.8))
                drop-shadow(0 0 30px rgba(56, 189, 248, 0.45));
        }

        #startScreen h1 {
            font-size: 32px;
            letter-spacing: 8px;
            text-transform: uppercase;
            margin-bottom: 6px;
            color: #e5f9ff;
        }

        #startScreen .subtitle-accent {
            font-size: 13px;
            letter-spacing: 3px;
            text-transform: uppercase;
            color: rgba(148, 163, 184, 0.9);
        }

        #startScreen .tagline {
            font-size: 17px;
            margin: 18px 0 6px;
            color: #e5f0ff;
            font-weight: 500;
        }

        #startScreen .description {
            font-size: 14px;
            margin-top: 6px;
            color: rgba(203, 213, 225, 0.78);
            line-height: 1.7;
        }

        .controls {
            margin-top: 22px;
            padding: 12px 14px;
            border-radius: 16px;
            background: radial-gradient(circle at top,
                        rgba(15, 23, 42, 0.9),
                        rgba(11, 15, 25, 0.98));
            border: 1px solid rgba(51, 65, 85, 0.9);
            font-size: 12px;
            color: rgba(203, 213, 225, 0.85);
        }

        .controls p {
            margin: 4px 0;
        }

        .key {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 26px;
            padding: 3px 7px;
            margin: 0 2px;
            border-radius: 6px;
            background: radial-gradient(circle at top,
                        rgba(255, 105, 180, 0.35),
                        rgba(255, 20, 147, 0.25));
            border: 1px solid rgba(255, 105, 180, 0.6);
            font-family: "SF Mono", Menlo, Consolas, monospace;
            font-size: 11px;
            color: #fff5e6;
            box-shadow:
                0 4px 12px rgba(0,0,0,.6),
                0 0 12px rgba(255,105,180,.45);
        }

        .primary-btn,
            .withdraw-btn {
                height: 52px;
            }

        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow:
                0 20px 50px rgba(40, 20, 8, 0.9),
                0 0 60px rgba(255, 149, 0, 0.7);
            filter: brightness(1.15);
        }

        .primary-btn:active {
            transform: translateY(0);
            box-shadow:
                0 12px 28px rgba(40, 20, 8, 0.9),
                0 0 30px rgba(255, 149, 0, 0.45);
        }

        /* ============ Game Over ============ */
        #gameOver .logo-small {
            width: 90px;
            height: auto;
            margin-bottom: 10px;
            filter:
                drop-shadow(0 10px 25px rgba(15, 23, 42, 0.9))
                drop-shadow(0 0 26px rgba(52, 211, 153, 0.5));
        }

        #gameOver h1 {
            font-size: 26px;
            letter-spacing: 8px;
            text-transform: uppercase;
            margin-bottom: 18px;
            color: #f9fafb;
        }

        .stat-block {
            margin: 14px 0;
        }

        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: rgba(148, 163, 184, 0.95);
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #ff69b4;
        }

        .meta-box {
            margin: 18px 0 6px;
            padding: 18px 16px;
            border-radius: 16px;
            background: radial-gradient(circle at top left,
                        rgba(0, 0, 0, 0.98),
                        rgba(0, 0, 0, 0.98));
            border: 1px solid rgba(51, 65, 85, 0.9);
            text-align: left;
            font-size: 12px;
            color: rgba(203, 213, 225, 0.88);
        }

        #leaderboardList {
            margin-top: 8px;
            font-size: 12px;
            line-height: 1.6;
        }

        #playerNameInput {
            width: 100%;
            padding: 10px 14px;
            border-radius: 10px;
            border: 1px solid rgba(255, 149, 0, 0.35);
            background: radial-gradient(circle at top,
                        rgba(50, 30, 10, 0.8),
                        rgba(20, 10, 4, 0.9));
            color: #ffe5cc;
            font-size: 15px;
            font-family: inherit;
            text-align: center;
            outline: none;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        #playerNameInput::placeholder {
            color: rgba(255, 149, 0, 0.5);
        }

        #playerNameInput:focus {
            border-color: rgba(255, 149, 0, 0.8);
            box-shadow: 0 0 20px rgba(255, 149, 0, 0.35);
        }

        /* Mobile tweaks */
        @media (max-width: 600px) {
            #ui {
                top: 18px;
                padding: 6px 14px;
                gap: 12px;
            }

            .hud-value {
                font-size: 15px;
            }

            #systemControls {
                right: 20px;
                bottom: 20px;
                gap: 8px;
            }

            #audioToggle, #fullscreenToggle {
                min-width: 80px;
                padding: 5px 10px;
            }

            .overlay-card {
                padding: 26px 20px 22px;
            }

            #startScreen h1 {
                font-size: 26px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div id="gameFrame">
            <canvas id="gameCanvas"></canvas>

            <!-- PREMIUM HUD -->
            <div id="ui">
            <div class="hud-pill">
                <span class="hud-label">Distance</span>
                <div class="hud-value-row">
                    <span class="hud-value" id="distance">0</span>
                    <span class="hud-unit">m</span>
                </div>
            </div>
            <div class="hud-pill">
                <span class="hud-label">Speed</span>
                <div class="hud-value-row">
                    <span class="hud-value" id="speed">1.0</span>
                    <span class="hud-unit">x</span>
                </div>
            </div>
            <div class="hud-pill">
                <span class="hud-label">Coins</span>
                <div class="hud-value-row">
                    <span class="hud-value" id="coins">0</span>
                    <span class="hud-unit">üí∞</span>
                </div>
            </div>
        </div>

        <div id="systemControls">
            <button id="fullscreenToggle">Fullscreen</button>
            <button id="audioToggle">Sound</button>
        </div>
        </div>

        <!-- START SCREEN -->
        <div id="startScreen" class="overlay-card">
            <div class="logo-container">
                <img src="https://i.postimg.cc/9rrtPG4T/t26-Logo-transpaent.png" alt="T26" />
            </div>
            <h1>T26 RUNNER</h1>
            <p class="subtitle-accent">VOLATILITY TRAINING MODULE</p>
            <p class="tagline">Survive the volatility.</p>
            <p class="description">
                Navigate through hostile market debris. Speed ramps up the longer you last.
                One impact ends the run. How far can you push before you lose control?
            </p>
            <div class="controls">
                <p><span class="key">A</span> <span class="key">D</span> or
                   <span class="key">‚Üê</span> <span class="key">‚Üí</span> ‚Äî Horizontal thrust</p>
                <p><span class="key">W</span> <span class="key">S</span> or
                   <span class="key">‚Üë</span> <span class="key">‚Üì</span> ‚Äî Vertical control</p>
            </div>
            <button id="startBtn" class="primary-btn">Start Run</button>
        </div>

        <!-- GAME OVER -->
        <div id="gameOver" class="overlay-card" style="display: none;">
            <img src="https://i.postimg.cc/kBBFNxVG/t26-Logo-icon.png" alt="T26" class="logo-small" />
            <h1>Run Ended</h1>
            <div class="stat-block">
                <p class="stat-label">Distance</p>
                <p class="stat-value"><span id="finalDistance">0</span>m</p>
            </div>
            <div class="stat-block">
                <p class="stat-label">Max Speed</p>
                <p class="stat-value"><span id="maxSpeed">1.0</span>x</p>
            </div>
            <div class="stat-block">
                <p class="stat-label">Coins Collected</p>
                <p class="stat-value"><span id="finalCoins">0</span> üí∞</p>
            </div>
            <div class="stat-block">
                <p class="stat-label">Your Name</p>
                <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20" />
            </div>
            <div class="meta-box">
                <p class="stat-label">Leaderboard</p>
                <div id="leaderboardList"></div>
            </div>
            <div style="display:flex; gap:12px; margin-top:8px; align-items:stretch;">
                <button id="restartBtn" class="primary-btn">Try Again</button>
                <button id="withdrawBtn" class="withdraw-btn">
                    <span>withdraw</span>
                    <span style="font-size:10px; opacity:.65">(coming soon..)</span>
                </button>
            </div>
        </div>
    </div>

    <script>
   
        const BASE_CANVAS_WIDTH = 1200; // Base reference width
        const BASE_CANVAS_HEIGHT = 800; // Base reference height
        const BASE_SCROLL_SPEED = 4;
        const PLATFORM_GAP = 300;
        const PLATFORM_WIDTH = 330;
        const PLATFORM_HEIGHT = 45;
        const PLATFORM_Y = 700;
        const LANE_SWITCH_COOLDOWN = 8;
        const INITIAL_OBSTACLE_SPAWN_RATE = 120;
        const MAX_OBSTACLE_DENSITY = 40;
        const PARTICLE_LIFETIME = 30;
        const MAX_PARTICLES = 200; // Limit particle count for performance

        // Base player physics constants
        const BASE_PLAYER_WIDTH = 180; // Increased from 140 to make rocket wider
        const BASE_PLAYER_HEIGHT = 105;
        const BASE_VERTICAL_SPEED = 10;
        const BASE_HORIZONTAL_SPEED = 10;
        const HOVER_DAMPENING = 0.25;
        const LANE_TRANSITION_SPEED = 0.2;


        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Dynamic values that update with fullscreen
        let CANVAS_WIDTH = BASE_CANVAS_WIDTH;
        let CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
        let PLAYER_WIDTH = BASE_PLAYER_WIDTH;
        let PLAYER_HEIGHT = BASE_PLAYER_HEIGHT;
        let VERTICAL_SPEED = BASE_VERTICAL_SPEED;
        let HORIZONTAL_SPEED = BASE_HORIZONTAL_SPEED;
        let canvasScale = 1;

        // Fullscreen-aware canvas resize
        function resizeCanvas() {
            const isFullscreen = !!(document.fullscreenElement ||
                                  document.webkitFullscreenElement ||
                                  document.mozFullScreenElement ||
                                  document.msFullscreenElement);

            if (isFullscreen) {
                // Fill entire screen while maintaining aspect ratio
                const windowAspect = window.innerWidth / window.innerHeight;
                const gameAspect = BASE_CANVAS_WIDTH / BASE_CANVAS_HEIGHT;

                if (windowAspect > gameAspect) {
                    // Window is wider - fit to height
                    CANVAS_HEIGHT = window.innerHeight;
                    CANVAS_WIDTH = Math.floor(CANVAS_HEIGHT * gameAspect);
                } else {
                    // Window is taller - fit to width
                    CANVAS_WIDTH = window.innerWidth;
                    CANVAS_HEIGHT = Math.floor(CANVAS_WIDTH / gameAspect);
                }

                canvasScale = CANVAS_WIDTH / BASE_CANVAS_WIDTH;
            } else {
                // Normal windowed mode - use base size
                CANVAS_WIDTH = BASE_CANVAS_WIDTH;
                CANVAS_HEIGHT = BASE_CANVAS_HEIGHT;
                canvasScale = 1;
            }

            // Update canvas dimensions
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;
            canvas.style.width = CANVAS_WIDTH + 'px';
            canvas.style.height = CANVAS_HEIGHT + 'px';

            // Update scaled gameplay values
            PLAYER_WIDTH = BASE_PLAYER_WIDTH * canvasScale;
            PLAYER_HEIGHT = BASE_PLAYER_HEIGHT * canvasScale;
            VERTICAL_SPEED = BASE_VERTICAL_SPEED * canvasScale;
            HORIZONTAL_SPEED = BASE_HORIZONTAL_SPEED * canvasScale;

            // Update player dimensions if already initialized
            if (typeof player !== 'undefined') {
                const prevScale = player.width / BASE_PLAYER_WIDTH;
                player.width = PLAYER_WIDTH;
                player.height = PLAYER_HEIGHT;

                // Scale player position proportionally
                player.x = (player.x / prevScale) * canvasScale;
                player.y = (player.y / BASE_CANVAS_HEIGHT) * CANVAS_HEIGHT;
                player.targetY = (player.targetY / BASE_CANVAS_HEIGHT) * CANVAS_HEIGHT;
            }

            // Scale all obstacles
            if (typeof obstacles !== 'undefined' && obstacles.length > 0) {
                obstacles.forEach(obs => {
                    obs.x = (obs.x / BASE_CANVAS_WIDTH) * CANVAS_WIDTH;
                    obs.y = (obs.y / BASE_CANVAS_HEIGHT) * CANVAS_HEIGHT;
                    obs.width = (obs.width / BASE_CANVAS_WIDTH) * CANVAS_WIDTH;
                    obs.height = (obs.height / BASE_CANVAS_HEIGHT) * CANVAS_HEIGHT;
                });
            }
        }


        let gameRunning = false;
        let distance = 0;
        let gameSpeed = 1;
        let maxSpeedReached = 1;
        let startTime = 0;
        let gameTime = 0; // Time elapsed in seconds
        let slowMotionFactor = 1; // For death animation
        let laneSwitchCooldown = 0;
        let deathAnimationActive = false;
        let animationFrameId = null; // RAF loop guard (prevents multiple loops)
        // lastHumFrame removed - no longer needed with jet engine sound
        let inputLocked = false; // Prevents accidental restart spam
        let cloudOffsetSlow = 0; // Parallax layer 1
        let cloudOffsetFast = 0; // Parallax layer 2
        let titleFadeOpacity = 0; // Branded title fade-in
        let titleFadeActive = false;

        // Player (T26 Rocket) - flying mid-screen
        const player = {
            x: 80,
            y: CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2, // Center vertically
            width: PLAYER_WIDTH,
            height: PLAYER_HEIGHT,
            velocityY: 0,
            thrustBoost: 1.0,
            targetX: 80,
            targetY: CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2, // Hover target
            lane: 1 // 0=left, 1=center, 2=right (kept for compatibility)
        };

        // Input handling
        const keys = {};

        // Cloud platforms
        const platforms = [];

        // Obstacles
        const obstacles = [];
        let obstacleTimer = 0;
        let obstacleSpawnRate = INITIAL_OBSTACLE_SPAWN_RATE;
        let patternIndex = 0;

        // Obstacle spawn patterns (strategic, not random)
        const OBSTACLE_PATTERNS = [
            ['center'],
            ['left', 'right'],
            ['center', 'center'],
            ['left', 'center'],
            ['right', 'center'],
            ['left'],
            ['right'],
            ['left', 'right', 'center']
        ];

        // Particle effects
        const particles = [];

        // Image-based explosion animations
        const explosions = [];

        // Background stars for decoration
        const backgroundStars = [];
        const STAR_COUNT = 80;

        // Milestone celebration system
        let lastMilestone = 0;
        let celebrationActive = false;
        let celebrationOpacity = 0;
        let celebrationMessage = '';
        let celebrationScale = 1;
        let celebrationSpawnPause = 0; // Frames to pause obstacle spawning during celebration

        // Speed tunnel visual effects
        const speedStreaks = [];
        const MAX_SPEED_STREAKS = 25;

        // Near-miss system
        const nearMisses = [];
        const NEAR_MISS_DISTANCE = 15; // pixels threshold for near miss

        // Bonus powerup system
        const bonuses = [];
        let bonusSpawnTimer = 0;
        const BONUS_SPAWN_INTERVAL = 600; // Spawn bonus every ~10 seconds
        let boostActive = false;

        // Coin/token collection system
        const coins = [];
        let coinSpawnTimer = 0;
        const COIN_SPAWN_INTERVAL = 120; // Spawn coins more frequently (~2 seconds)
        let totalCoins = 0;
        let boostDuration = 0;
        const BOOST_DURATION_FRAMES = 90; // 1.5 seconds at 60fps
        const BOOST_SPEED_MULTIPLIER = 3;
        const BONUS_POINTS = 100;

        // Background zone system
        let currentZone = 0;
        let zoneTransitionActive = false;
        let zoneTransitionOpacity = 0;
        let zoneTransitionMessage = '';

        const fxIntensity = {
            rocket: 1.0,
            obstacles: 1.0,
            background: 1.0,
            tunnel: 1.0,
            ui: 1.0
        };


        const images = {
            logo: new Image(),
            logoIcon: new Image(),
            logoTransparent: new Image(),
            bitcoin: new Image(),
            ethereum: new Image(),
            solana: new Image(),
            shib: new Image(),
            bnb: new Image(),
            explosion: new Image()
        };

        //"https://i.postimg.cc/wjy83HnB/logo.png"


        // Preload images
        images.logo.src = 'https://i.postimg.cc/9rrtPG4T/t26-Logo-transpaent.png';
        images.logoIcon.src = 'https://i.postimg.cc/Rh9JkLqw/logo.png';  // Local logo file for the rocket
        images.logoTransparent.src = 'https://i.postimg.cc/9rrtPG4T/t26-Logo-transpaent.png';

        // Crypto logos
        images.bitcoin.src = 'https://cryptologos.cc/logos/bitcoin-btc-logo.png?v=040';
        images.ethereum.src = 'https://cryptologos.cc/logos/ethereum-eth-logo.png?v=040';
        images.solana.src = 'https://cryptologos.cc/logos/solana-sol-logo.png?v=040';
        images.shib.src = 'https://cryptologos.cc/logos/shiba-inu-shib-logo.png?v=040';
        images.bnb.src = 'https://cryptologos.cc/logos/bnb-bnb-logo.png?v=040';

        // Explosion image
        images.explosion.src = 'https://i.postimg.cc/JDsrRjMt/explosion.png';

        let imagesLoaded = 0;
        const totalImages = 9;

        function checkImagesLoaded() {
            imagesLoaded++;
            if (imagesLoaded === totalImages) {
                console.log('T26 assets loaded successfully');
            }
        }

        images.logo.onload = checkImagesLoaded;
        images.logoIcon.onload = checkImagesLoaded;
        images.logoTransparent.onload = checkImagesLoaded;
        images.bitcoin.onload = checkImagesLoaded;
        images.ethereum.onload = checkImagesLoaded;
        images.solana.onload = checkImagesLoaded;
        images.shib.onload = checkImagesLoaded;
        images.bnb.onload = checkImagesLoaded;

        // Fallback for image load errors
        images.logo.onerror = () => console.warn('Logo failed to load');
        images.logoIcon.onerror = () => console.warn('Logo icon failed to load');
        images.logoTransparent.onerror = () => console.warn('Logo transparent failed to load');
        images.bitcoin.onerror = () => console.warn('Bitcoin logo failed to load');
        images.ethereum.onerror = () => console.warn('Ethereum logo failed to load');
        images.solana.onerror = () => console.warn('Solana logo failed to load');
        images.shib.onerror = () => console.warn('Shiba Inu logo failed to load');
        images.bnb.onerror = () => console.warn('BNB logo failed to load');

        // Initialize canvas sizing after all objects are defined
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);


        function initializeStars() {
            backgroundStars.length = 0;
            for (let i = 0; i < STAR_COUNT; i++) {
                backgroundStars.push({
                    x: Math.random() * CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    size: Math.random() * 2 + 0.5,
                    speed: Math.random() * 0.5 + 0.2,
                    opacity: Math.random() * 0.5 + 0.3,
                    twinkleSpeed: Math.random() * 0.02 + 0.01,
                    twinklePhase: Math.random() * Math.PI * 2
                });
            }
        }

        function updateStars() {
            for (let star of backgroundStars) {
                star.x -= star.speed * gameSpeed * canvasScale;

                // Wrap around when star goes off screen
                if (star.x < 0) {
                    star.x = CANVAS_WIDTH;
                    star.y = Math.random() * CANVAS_HEIGHT;
                }

                // Twinkling effect
                star.twinklePhase += star.twinkleSpeed;
            }
        }

        function drawStars() {
            for (let star of backgroundStars) {
                const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
                ctx.globalAlpha = star.opacity * twinkle;
                ctx.fillStyle = '#e0f2f1';
                ctx.beginPath();
                ctx.arc(star.x, star.y, star.size * canvasScale, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;
        }

        // Initialize stars
        initializeStars();

        function saveScore(distance, maxSpeed, playerName) {
            // Use "Anonymous" if no name provided
            const name = playerName && playerName.trim() ? playerName.trim() : 'Anonymous';

            const newDistance = Math.floor(distance);

            let leaderboard = JSON.parse(localStorage.getItem('t26Leaderboard') || '[]');

            // Check if player already exists
            const existingPlayerIndex = leaderboard.findIndex(score => score.name === name);

            if (existingPlayerIndex !== -1) {
                // Player exists - only update if new score is better
                if (newDistance > leaderboard[existingPlayerIndex].distance) {
                    leaderboard[existingPlayerIndex].distance = newDistance;
                    leaderboard[existingPlayerIndex].maxSpeed = maxSpeed.toFixed(1);
                    leaderboard[existingPlayerIndex].date = new Date().toISOString();
                }
            } else {
                // New player - add to leaderboard
                const score = {
                    name: name,
                    distance: newDistance,
                    maxSpeed: maxSpeed.toFixed(1),
                    date: new Date().toISOString()
                };
                leaderboard.push(score);
            }

            leaderboard.sort((a, b) => b.distance - a.distance);
            leaderboard = leaderboard.slice(0, 10); // Keep top 10
            localStorage.setItem('t26Leaderboard', JSON.stringify(leaderboard));

            return leaderboard;
        }

        function displayLeaderboard() {
            const leaderboard = JSON.parse(localStorage.getItem('t26Leaderboard') || '[]');
            const listElement = document.getElementById('leaderboardList');

            if (leaderboard.length === 0) {
                listElement.innerHTML = '<p style="text-align: center; color: rgba(255,255,255,0.4);">No scores yet</p>';
                return;
            }

            let html = '';
            leaderboard.forEach((score, index) => {
                const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
                const isCurrentScore = score.distance === Math.floor(distance) && Math.abs(parseFloat(score.maxSpeed) - maxSpeedReached) < 0.1;
                const highlight = isCurrentScore ? 'background: rgba(255,149,0,0.2); padding: 5px; border-radius: 3px;' : '';
                html += `<div style="margin: 8px 0; ${highlight}">
                    <span style="display: inline-block; width: 30px;">${medal}</span>
                    <span style="color: #ffffff; font-weight: 500; margin-right: 8px;">${score.name}</span>
                    <span style="color: #ff9500; font-weight: 600;">${score.distance}m</span>
                    <span style="color: rgba(255,255,255,0.5); margin-left: 10px;">${score.maxSpeed}x</span>
                </div>`;
            });
            listElement.innerHTML = html;
        }

        function updatePlayerName(newName) {
            // Update the most recent score's name (the one from this game session)
            let leaderboard = JSON.parse(localStorage.getItem('t26Leaderboard') || '[]');

            if (leaderboard.length === 0) return;

            // Find the score that matches the current game's distance and speed
            const currentDistance = Math.floor(distance);
            const currentSpeed = maxSpeedReached.toFixed(1);

            for (let i = 0; i < leaderboard.length; i++) {
                if (leaderboard[i].distance === currentDistance &&
                    leaderboard[i].maxSpeed === currentSpeed) {
                    // Update the name
                    leaderboard[i].name = newName && newName.trim() ? newName.trim() : 'Anonymous';
                    localStorage.setItem('t26Leaderboard', JSON.stringify(leaderboard));
                    displayLeaderboard();
                    break;
                }
            }
        }


        let audioEnabled = true;
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        // Load audio files
        const audioFiles = {
            explosion: new Audio('https://img1.wsimg.com/blobby/go/10fe88df-65cd-42af-9ccc-38c6c378e41e/downloads/095a1665-61a1-4e96-8455-979affd69301/hq-explosion-6288.mp3?ver=1765279786747'),
            levelUp: new Audio('https://img1.wsimg.com/blobby/go/10fe88df-65cd-42af-9ccc-38c6c378e41e/downloads/3b5a0802-3e05-4cbb-9d2a-424203f0a035/level-up-06-370051.mp3?ver=1765279786747'),
            boost: new Audio('https://img1.wsimg.com/blobby/go/10fe88df-65cd-42af-9ccc-38c6c378e41e/downloads/ca0ff3c8-3867-492e-b621-b2915454d279/white-noise-reverse-76836.mp3?ver=1765279786747'),
            coin: new Audio('https://img1.wsimg.com/blobby/go/10fe88df-65cd-42af-9ccc-38c6c378e41e/downloads/3061b164-33a0-4e16-9881-dfd68df71d9f/clear-combo-4-394493.mp3?ver=1765279786747'),
            jetEngine: new Audio('https://img1.wsimg.com/blobby/go/10fe88df-65cd-42af-9ccc-38c6c378e41e/downloads/8225bde3-ac81-448b-a2d5-4d42b72f6a8f/starting-of-jet-engine-286108.mp3?ver=1765279786747')
        };

        // Set volume for audio files
        audioFiles.explosion.volume = 0.25;  // Lowered explosion volume
        audioFiles.levelUp.volume = 0.4;
        audioFiles.boost.volume = 0.6;
        audioFiles.coin.volume = 0.5;
        audioFiles.jetEngine.volume = 0.15;  // Lowered jet engine volume

        // Preload audio files
        audioFiles.explosion.load();
        audioFiles.levelUp.load();
        audioFiles.boost.load();
        audioFiles.coin.load();
        audioFiles.jetEngine.load();

        // AudioContext autoplay compliance - ensures activation after user gesture
        function unlockAudio() {
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }

        // Play audio file
        function playAudioFile(audioName) {
            if (!audioEnabled) return;
            const audioElement = audioFiles[audioName];
            if (!audioElement) {
                console.warn('Audio file not found:', audioName);
                return;
            }
            audioElement.currentTime = 0; // Reset to start
            audioElement.play().catch(e => console.warn('Audio play failed:', e));
        }

        function playSound(frequency, duration, type = 'sine') {
            if (!audioEnabled) return;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            oscillator.frequency.value = frequency;
            oscillator.type = type;

            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        // Jet engine flight sound (loops 10-15 second segment)
        let jetEngineStarted = false;

        function setupJetEngineLoop() {
            const jetAudio = audioFiles.jetEngine;

            // Listen for time updates to loop back to 36 seconds
            jetAudio.addEventListener('timeupdate', function() {
                if (jetAudio.currentTime >= 58) {
                    jetAudio.currentTime = 36;
                }
            });
        }

        function startJetEngine() {
            if (!audioEnabled || jetEngineStarted) return;

            const jetAudio = audioFiles.jetEngine;
            jetAudio.currentTime = 36; // Start at 36 seconds
            jetAudio.loop = false; // We handle looping manually
            jetAudio.play().catch(e => console.warn('Jet engine play failed:', e));
            jetEngineStarted = true;
        }

        function stopJetEngine() {
            if (!jetEngineStarted) return;

            const jetAudio = audioFiles.jetEngine;
            jetAudio.pause();
            jetEngineStarted = false;
        }

        function playJumpSound() {
            playSound(400, 0.1, 'square');
        }

        function playDeathSound() {
            playAudioFile('explosion');
        }

        document.addEventListener('keydown', (e) => {
            const blockedKeys = [
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                'Space', 'PageUp', 'PageDown'
            ];

            if (blockedKeys.includes(e.code) || blockedKeys.includes(e.key)) {
                e.preventDefault();
            }

            keys[e.code] = true;
        }, { passive: false });

        document.addEventListener('keyup', (e) => {
            const blockedKeys = [
                'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
                'Space', 'PageUp', 'PageDown'
            ];

            if (blockedKeys.includes(e.code) || blockedKeys.includes(e.key)) {
                e.preventDefault();
            }

            keys[e.code] = false;
        }, { passive: false });

        document.getElementById('startBtn').addEventListener('click', () => {
            unlockAudio(); // Browser autoplay compliance
            startGame();
        });

        document.getElementById('restartBtn').addEventListener('click', () => {
            if (inputLocked) return; // Prevent accidental spam
            unlockAudio();
            restartGame();
        });

        document.getElementById('audioToggle').addEventListener('click', () => {
            unlockAudio(); // Activate on toggle too
            audioEnabled = !audioEnabled;
            document.getElementById('audioToggle').textContent = audioEnabled ? 'SOUND: ON' : 'SOUND: OFF';

            // Mute/unmute all audio files
            for (const key in audioFiles) {
                audioFiles[key].muted = !audioEnabled;
            }

            // Stop jet engine if muting
            if (!audioEnabled) {
                stopJetEngine();
            } else if (gameRunning) {
                // Restart jet engine if unmuting during gameplay
                startJetEngine();
            }
        });

        document.getElementById('fullscreenToggle').addEventListener('click', () => {
            toggleFullscreen();
        });

        // Update player name in leaderboard when they type it
        document.getElementById('playerNameInput').addEventListener('input', (e) => {
            updatePlayerName(e.target.value);
        });

        // Fullscreen toggle function
        function toggleFullscreen() {
            if (!document.fullscreenElement &&
                !document.webkitFullscreenElement &&
                !document.mozFullScreenElement &&
                !document.msFullscreenElement) {
                // Enter fullscreen
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    elem.webkitRequestFullscreen();
                } else if (elem.mozRequestFullScreen) {
                    elem.mozRequestFullScreen();
                } else if (elem.msRequestFullscreen) {
                    elem.msRequestFullscreen();
                }
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.mozCancelFullScreen) {
                    document.mozCancelFullScreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
            }
        }

        // Update button text and resize canvas when fullscreen state changes
        document.addEventListener('fullscreenchange', handleFullscreenChange);
        document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
        document.addEventListener('mozfullscreenchange', handleFullscreenChange);
        document.addEventListener('MSFullscreenChange', handleFullscreenChange);

        function handleFullscreenChange() {
            updateFullscreenButton();
            resizeCanvas(); // Resize canvas to fill fullscreen
        }

        function updateFullscreenButton() {
            const isFullscreen = document.fullscreenElement ||
                               document.webkitFullscreenElement ||
                               document.mozFullScreenElement ||
                               document.msFullscreenElement;
            document.getElementById('fullscreenToggle').textContent = isFullscreen ? 'EXIT FULLSCREEN' : 'FULLSCREEN';
        }


        function stopGameLoop() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            stopGameLoop(); // Prevent multiple RAF loops
            gameRunning = true;
            startTime = performance.now();
            resetGame();

            // Start jet engine sound
            setupJetEngineLoop();
            startJetEngine();

            // Trigger branded title fade-in
            titleFadeActive = true;
            titleFadeOpacity = 0.15; // Start visible
            setTimeout(() => {
                // Fade out after 1.5 seconds
                const fadeOut = setInterval(() => {
                    titleFadeOpacity -= 0.01;
                    if (titleFadeOpacity <= 0) {
                        titleFadeOpacity = 0;
                        titleFadeActive = false;
                        clearInterval(fadeOut);
                    }
                }, 30);
            }, 1500);

            gameLoop();
        }

        function restartGame() {
            document.getElementById('gameOver').style.display = 'none';
            stopGameLoop(); // Clean up before restart
            gameRunning = true;
            deathAnimationActive = false;
            slowMotionFactor = 1;
            inputLocked = false;
            startTime = performance.now();
            resetGame();

            // Restart jet engine sound
            startJetEngine();

            gameLoop();
        }

        function resetGame() {
            distance = 0;
            gameSpeed = 1;
            maxSpeedReached = 1;
            gameTime = 0;
            player.x = 80 * canvasScale;
            player.y = CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2;
            player.targetX = 80 * canvasScale;
            player.targetY = CANVAS_HEIGHT / 2 - PLAYER_HEIGHT / 2;
            player.velocityY = 0;
            player.lane = 1;
            player.width = PLAYER_WIDTH;
            player.height = PLAYER_HEIGHT;
            platforms.length = 0;
            obstacles.length = 0;
            particles.length = 0;
            obstacleTimer = 0;
            obstacleSpawnRate = INITIAL_OBSTACLE_SPAWN_RATE;
            patternIndex = 0;
            laneSwitchCooldown = 0;
            cloudOffsetSlow = 0;
            cloudOffsetFast = 0;
            titleFadeOpacity = 0;
            titleFadeActive = false;
            lastMilestone = 0;
            celebrationActive = false;
            celebrationOpacity = 0;
            celebrationSpawnPause = 0;
            speedStreaks.length = 0;
            nearMisses.length = 0;
            bonuses.length = 0;
            bonusSpawnTimer = 0;
            boostActive = false;
            boostDuration = 0;
            coins.length = 0;
            coinSpawnTimer = 0;
            totalCoins = 0;
            currentZone = 0;
            zoneTransitionActive = false;
            zoneTransitionOpacity = 0;
            initializeStars(); // Reinitialize stars for new game
        }

        function gameLoop() {
            if (!gameRunning) return;

            update();
            draw();
            animationFrameId = requestAnimationFrame(gameLoop); // Store RAF ID
        }


        function update() {
            // Calculate game time and psychologically smooth difficulty curve
            gameTime = (performance.now() - startTime) / 1000; // seconds
            const elapsedMinutes = gameTime / 60;

            // Smooth speed scaling using logarithmic curve (no sudden jumps)
            gameSpeed = 1 + Math.log1p(elapsedMinutes) * 0.8;
            maxSpeedReached = Math.max(maxSpeedReached, gameSpeed);

            // Update distance
            distance += gameSpeed * 0.5;

            // Check for milestone celebrations
            checkMilestones();


            // Effect priority logic ‚Äî rocket always wins
            fxIntensity.tunnel = Math.max(0.35, 1 - (gameSpeed - 1) * 0.25);

            fxIntensity.background = celebrationActive ? 0.5 : 0.85;

            fxIntensity.obstacles = celebrationActive ? 0.7 : 1.0;

            fxIntensity.rocket = celebrationActive || nearMisses.length > 0 ? 1.25 : 1.0;

            // Proximity-based rocket glow boost (clutch moments)
            let dangerProximity = 0;
            for (let obs of obstacles) {
                const dx = Math.abs((player.x + player.width / 2) - (obs.x + obs.width / 2));
                const dy = Math.abs((player.y + player.height / 2) - (obs.y + obs.height / 2));
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < 180 * canvasScale) {
                    dangerProximity = Math.max(dangerProximity, 1 - dist / (180 * canvasScale));
                }
            }
            fxIntensity.rocket = Math.max(fxIntensity.rocket, 1 + dangerProximity * 0.8);

            // Gradually increase obstacle density (smooth curve, not modulo spikes)
            const densityFactor = Math.min(1, elapsedMinutes / 2);
            obstacleSpawnRate = INITIAL_OBSTACLE_SPAWN_RATE - (densityFactor * (INITIAL_OBSTACLE_SPAWN_RATE - MAX_OBSTACLE_DENSITY));

            // Update UI
            document.getElementById('distance').textContent = Math.floor(distance);
            document.getElementById('speed').textContent = gameSpeed.toFixed(1);
            document.getElementById('coins').textContent = totalCoins;

            // Check for zone transitions
            const newZone = Math.floor(distance / 500) % 5;
            if (newZone !== currentZone && distance > 0) {
                currentZone = newZone;
                triggerZoneTransition(newZone);
            }

            // Update zone transition animation
            if (zoneTransitionActive) {
                zoneTransitionOpacity -= 0.015;
                if (zoneTransitionOpacity <= 0) {
                    zoneTransitionActive = false;
                }
            }

            // Engine hum removed - now using jet engine looping sound

            // Player horizontal movement with cooldown (prevents accidental double-taps)
            const lanes = [80 * canvasScale, CANVAS_WIDTH/2 - player.width/2, CANVAS_WIDTH - 180 * canvasScale];

            // Player horizontal movement (smooth left/right)
            if (keys['ArrowLeft'] || keys['KeyA']) {
                player.targetX -= HORIZONTAL_SPEED * slowMotionFactor;
            }
            if (keys['ArrowRight'] || keys['KeyD']) {
                player.targetX += HORIZONTAL_SPEED * slowMotionFactor;
            }

            // Clamp horizontal position to screen bounds (scaled)
            const minX = 80 * canvasScale;
            const maxX = CANVAS_WIDTH - player.width - 80 * canvasScale;
            player.targetX = Math.max(minX, Math.min(maxX, player.targetX));

            // Smooth horizontal movement to target position
            player.x += (player.targetX - player.x) * HOVER_DAMPENING;

            // Player vertical movement (flying controls)
            if (keys['ArrowUp'] || keys['KeyW']) {
                player.targetY -= VERTICAL_SPEED * slowMotionFactor;
            }
            if (keys['ArrowDown'] || keys['KeyS']) {
                player.targetY += VERTICAL_SPEED * slowMotionFactor;
            }

            // Clamp target position to screen bounds (scaled)
            const minY = 80 * canvasScale;
            const maxY = CANVAS_HEIGHT - player.height - 80 * canvasScale;
            player.targetY = Math.max(minY, Math.min(maxY, player.targetY));

            // Smooth movement to target position (hovering effect)
            player.y += (player.targetY - player.y) * HOVER_DAMPENING;

            // Update velocityY for flame effects
            player.velocityY = (player.targetY - player.y) * 0.5;

            // Update velocityX for flame effects
            player.velocityX = (player.targetX - player.x) * 0.5;

            // Track thrust boost for flame intensity (increases with velocity in any direction)
            const verticalMovement = Math.abs(player.velocityY);
            const horizontalMovement = Math.abs(player.velocityX);
            const totalMovement = Math.sqrt(verticalMovement * verticalMovement + horizontalMovement * horizontalMovement);
            player.thrustBoost = 1.0 + Math.min(totalMovement / 5, 0.8); // Scale boost based on total velocity

    
            // Pause spawning during celebrations for 0.5s grace period
            if (celebrationSpawnPause > 0) {
                celebrationSpawnPause--;
            } else {
                obstacleTimer++;
                if (obstacleTimer > obstacleSpawnRate) {
                    spawnObstaclePattern();
                    obstacleTimer = 0;
                }
            }

            // Spawn bonus powerups periodically
            if (!boostActive) {
                bonusSpawnTimer++;
                if (bonusSpawnTimer > BONUS_SPAWN_INTERVAL) {
                    spawnBonus();
                    bonusSpawnTimer = 0;
                }
            }

            // Spawn coins periodically
            coinSpawnTimer++;
            if (coinSpawnTimer > COIN_SPAWN_INTERVAL) {
                spawnCoin();
                coinSpawnTimer = 0;
            }

            // Update boost state
            if (boostActive) {
                boostDuration--;
                if (boostDuration <= 0) {
                    boostActive = false;
                }
            }

            // Update bonuses
            const currentBoostSpeed = boostActive ? gameSpeed * BOOST_SPEED_MULTIPLIER : gameSpeed;
            for (let i = bonuses.length - 1; i >= 0; i--) {
                const bonus = bonuses[i];
                bonus.x -= gameSpeed * BASE_SCROLL_SPEED * canvasScale;
                bonus.rotation += 0.05;

                // Remove off-screen bonuses
                if (bonus.x + bonus.width < 0) {
                    bonuses.splice(i, 1);
                }

                // Check for collection
                if (checkCollision(player, bonus)) {
                    collectBonus(i);
                }
            }

            // Update coins
            for (let i = coins.length - 1; i >= 0; i--) {
                const coin = coins[i];
                coin.x -= gameSpeed * BASE_SCROLL_SPEED * canvasScale;
                coin.rotation += 0.1;
                coin.floatOffset += 0.08;

                // Remove if off-screen
                if (coin.x + coin.width < 0) {
                    coins.splice(i, 1);
                    continue;
                }

                // Check for collection
                if (checkCollision(player, coin)) {
                    collectCoin(i);
                }
            }

            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obs = obstacles[i];
                obs.x -= currentBoostSpeed * BASE_SCROLL_SPEED * canvasScale;

                // Update age for spawn animation
                if (!obs.age) obs.age = 0;
                obs.age++;

                // Update obstacle-specific behaviors
                if (obs.type === 'bitcoin' && obs.rotation !== undefined) {
                    obs.rotation += obs.rotationSpeed * gameSpeed;
                }
                if (obs.type === 'ethereum' && obs.driftOffset !== undefined) {
                    obs.driftOffset += obs.driftSpeed;
                    obs.y = obs.originalY + Math.sin(obs.driftOffset) * 3 * canvasScale; // Gentle floating effect
                }
                if (obs.type === 'solana' && obs.rotation !== undefined) {
                    obs.rotation += obs.rotationSpeed * gameSpeed;
                }
                if (obs.type === 'shib' && obs.pulse !== undefined) {
                    obs.pulse += obs.pulseSpeed;
                }
                if (obs.type === 'bnb' && obs.rotation !== undefined) {
                    obs.rotation += obs.rotationSpeed * gameSpeed;
                }

                // Remove off-screen obstacles
                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                }

                // Collision detection - triggers game over (unless boost is active)
                if (checkCollision(player, obs)) {
                    if (boostActive) {
                        // Destroy obstacle with confetti
                        const x = obs.x + obs.width/2;
                        const y = obs.y + obs.height/2;
                        createParticles(x, y, '#ff6600', 15);  // Orange
                        createParticles(x, y, '#ff9500', 12);  // Bright orange
                        createParticles(x, y, '#ffd700', 10);  // Gold
                        obstacles.splice(i, 1);
                        distance += 10; // Bonus distance for destroying obstacle
                    } else {
                        endGame();
                    }
                }
            }

            // Check for near misses
            checkNearMisses();

            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;

                // Apply gravity if particle has it, otherwise default
                if (p.gravity !== undefined) {
                    p.vy += p.gravity;
                } else {
                    p.vy += 0.3;
                }

                // SMOKE RISES (buoyancy effect for realism)
                if (p.type === 'smoke') {
                    p.vy -= 0.05 * canvasScale; // Smoke rises slowly
                }

                // Update rotation for debris
                if (p.rotation !== undefined && p.rotationSpeed !== undefined) {
                    p.rotation += p.rotationSpeed;
                }

                // FIRE FADES FAST - smoke dominates after 10-15 frames
                if (p.type === 'fire' && p.maxLife && p.life < p.maxLife * 0.6) {
                    if (p.alpha !== undefined) {
                        p.alpha *= 0.92; // Accelerated fade for fire
                    }
                }

                // Fade out smoke and fire over time
                if (p.alpha !== undefined) {
                    p.alpha = p.life / 70; // Fade based on remaining life
                }

                p.life--;

                // Remove particles that are off-screen or dead
                if (p.life <= 0 ||
                    p.x < -100 || p.x > CANVAS_WIDTH + 100 ||
                    p.y < -100 || p.y > CANVAS_HEIGHT + 100) {
                    particles.splice(i, 1);
                }
            }

            // Update background stars
            updateStars();

            // Update speed streaks (tunnel compression effect)
            updateSpeedStreaks();

            // Update near-miss effects
            updateNearMisses();

            // Update explosion animations
            updateExplosions();

            // Update celebration animation
            if (celebrationActive) {
                celebrationOpacity -= 0.01;
                celebrationScale += 0.02;
                if (celebrationOpacity <= 0) {
                    celebrationActive = false;
                }
            }
        }

        function updateSpeedStreaks() {
            // Generate new streaks based on speed
            const streakChance = gameSpeed / 10; // More streaks at higher speed
            if (Math.random() < streakChance && speedStreaks.length < MAX_SPEED_STREAKS) {
                speedStreaks.push({
                    x: CANVAS_WIDTH,
                    y: Math.random() * CANVAS_HEIGHT,
                    length: (50 + Math.random() * 100) * canvasScale,
                    speed: (3 + Math.random() * 4) * gameSpeed * canvasScale,
                    opacity: 0.05 + Math.random() * 0.08,
                    width: (1 + Math.random() * 2) * canvasScale
                });
            }

            // Update existing streaks
            for (let i = speedStreaks.length - 1; i >= 0; i--) {
                const streak = speedStreaks[i];
                streak.x -= streak.speed;

                // Remove off-screen streaks
                if (streak.x + streak.length < 0) {
                    speedStreaks.splice(i, 1);
                }
            }
        }

        function drawSpeedStreaks() {
            for (let streak of speedStreaks) {
                const gradient = ctx.createLinearGradient(streak.x, 0, streak.x - streak.length, 0);
                gradient.addColorStop(0, `rgba(140, 220, 255, ${streak.opacity})`);
                gradient.addColorStop(1, 'rgba(140, 220, 255, 0)');

                ctx.fillStyle = gradient;
                ctx.fillRect(streak.x - streak.length, streak.y, streak.length, streak.width);
            }
        }


        function checkNearMisses() {
            for (let obs of obstacles) {
                // Check if player just passed obstacle (is now to the right of it)
                const playerPassed = player.x > obs.x + obs.width;
                const wasClose = Math.abs((player.x + player.width/2) - (obs.x + obs.width/2)) < NEAR_MISS_DISTANCE * canvasScale;
                const verticallyAligned = !(player.y > obs.y + obs.height || player.y + player.height < obs.y);

                if (playerPassed && wasClose && verticallyAligned && !obs.nearMissTriggered) {
                    obs.nearMissTriggered = true;
                    triggerNearMiss(obs);
                }
            }
        }

        function triggerNearMiss(obs) {
            // Add near-miss visual effect
            nearMisses.push({
                x: obs.x + obs.width / 2,
                y: obs.y + obs.height / 2,
                radius: Math.max(obs.width, obs.height),
                opacity: 0.8,
                life: 15
            });

            // Play near-miss sound
            if (audioEnabled) {
                playSound(800, 0.05, 'sine');
            }
        }

        function updateNearMisses() {
            for (let i = nearMisses.length - 1; i >= 0; i--) {
                const miss = nearMisses[i];
                miss.life--;
                miss.opacity = miss.life / 15;
                miss.radius += 3 * canvasScale;

                if (miss.life <= 0) {
                    nearMisses.splice(i, 1);
                }
            }
        }

        function drawNearMisses() {
            for (let miss of nearMisses) {
                ctx.save();
                ctx.globalAlpha = miss.opacity * fxIntensity.rocket;

                const segments = 6;
                const angleStep = (Math.PI * 2) / segments;
                const r = miss.radius;

                // Angular segments (technical, sharp look)
                const gradient = ctx.createLinearGradient(miss.x - r, miss.y, miss.x + r, miss.y);
                gradient.addColorStop(0, 'rgba(255, 149, 0, 0.9)'); // Orange
                gradient.addColorStop(0.5, 'rgba(255, 200, 50, 0.9)'); // Yellow
                gradient.addColorStop(1, 'rgba(255, 255, 255, 0.9)'); // White

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 3 * canvasScale;

                // Draw segmented rings
                for (let i = 0; i < segments; i++) {
                    const a0 = i * angleStep;
                    const a1 = a0 + angleStep * 0.6; // 60% of segment (gaps between)

                    ctx.beginPath();
                    ctx.arc(miss.x, miss.y, r, a0, a1);
                    ctx.stroke();
                }

                // Inner accent ring
                ctx.strokeStyle = `rgba(255, 200, 50, ${miss.opacity * 0.7})`;
                ctx.lineWidth = 2 * canvasScale;
                for (let i = 0; i < segments; i++) {
                    const a0 = i * angleStep;
                    const a1 = a0 + angleStep * 0.6;

                    ctx.beginPath();
                    ctx.arc(miss.x, miss.y, r * 0.7, a0, a1);
                    ctx.stroke();
                }

                // Energy sparks radiating outward
                ctx.strokeStyle = `rgba(0, 255, 255, ${miss.opacity * 0.7})`;
                ctx.lineWidth = 2 * canvasScale;
                for (let i = 0; i < 4; i++) {
                    const angle = (Math.PI / 2) * i + (miss.life * 0.1); // Slight rotation
                    const sparkLength = r * 0.4;

                    ctx.beginPath();
                    ctx.moveTo(
                        miss.x + Math.cos(angle) * r,
                        miss.y + Math.sin(angle) * r
                    );
                    ctx.lineTo(
                        miss.x + Math.cos(angle) * (r + sparkLength),
                        miss.y + Math.sin(angle) * (r + sparkLength)
                    );
                    ctx.stroke();
                }

                ctx.restore();
            }
        }


        function checkMilestones() {
            const currentDistance = Math.floor(distance);
            const milestones = [500, 1000, 1500, 2000, 2500, 3000, 4000, 5000];

            for (let milestone of milestones) {
                if (currentDistance >= milestone && lastMilestone < milestone) {
                    lastMilestone = milestone;
                    triggerCelebration(milestone);
                    break;
                }
            }
        }

        function triggerCelebration(milestone) {
            celebrationActive = true;
            celebrationOpacity = 1;
            celebrationScale = 1;
            celebrationSpawnPause = 0; // No pause - keep the game flowing

            // Different messages for different milestones
            const messages = [
                `${milestone}m!!! LET'S GOOO! üöÄ`,
                `${milestone}m! UNSTOPPABLE! üí™`,
                `${milestone}m! ON FIRE! üî•`,
                `${milestone}m! CRUSHING IT! ‚ö°`,
                `${milestone}m! BEAST MODE! üí•`
            ];

            celebrationMessage = messages[Math.floor(Math.random() * messages.length)];

            // Play celebration sound
            playCelebrationSound();

            // Create celebration particles
            createCelebrationParticles();
        }

        function playCelebrationSound() {
            // Play level-up sound for milestone celebrations
            playAudioFile(audioFiles.levelUp);
        }

        function createCelebrationParticles() {
            const colors = ['#ffd700', '#ffed4e', '#ff9500', '#ff6b00', '#ff6b6b'];
            for (let i = 0; i < 30; i++) {
                particles.push({
                    x: CANVAS_WIDTH / 2 + (Math.random() - 0.5) * 200 * canvasScale,
                    y: CANVAS_HEIGHT / 3 + (Math.random() - 0.5) * 100 * canvasScale,
                    vx: (Math.random() - 0.5) * 8 * canvasScale,
                    vy: (Math.random() - 0.5) * 8 * canvasScale,
                    color: colors[Math.floor(Math.random() * colors.length)],
                    life: 40
                });
            }
        }

    
        function triggerZoneTransition(zone) {
            zoneTransitionActive = true;
            zoneTransitionOpacity = 1;

            const zoneNames = [
                'DEEP SPACE',
                'PURPLE NEBULA',
                'RED MARS',
                'GREEN AURORA',
                'GOLDEN SUNSET'
            ];

            zoneTransitionMessage = `Entering ${zoneNames[zone]}`;

            // Play zone transition sound (level up sound)
            playAudioFile('levelUp');
        }

        function draw() {
            // Dynamic background that changes based on distance
            const backgroundTheme = Math.floor(distance / 500) % 5; // Change every 500m, 5 different themes

            const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);

            switch(backgroundTheme) {
                case 0: // Deep Blue Space (0-499m)
                    gradient.addColorStop(0, '#0d1b2a');
                    gradient.addColorStop(0.5, '#1b263b');
                    gradient.addColorStop(1, '#415a77');
                    break;
                case 1: // Purple Nebula (500-999m)
                    gradient.addColorStop(0, '#1a0d2e');
                    gradient.addColorStop(0.5, '#2d1b3d');
                    gradient.addColorStop(1, '#5a3d77');
                    break;
                case 2: // Dark Red Mars (1000-1499m)
                    gradient.addColorStop(0, '#2e0d0d');
                    gradient.addColorStop(0.5, '#3d1b1b');
                    gradient.addColorStop(1, '#774141');
                    break;
                case 3: // Green Aurora (1500-1999m)
                    gradient.addColorStop(0, '#0d2e1a');
                    gradient.addColorStop(0.5, '#1b3d2d');
                    gradient.addColorStop(1, '#3d7758');
                    break;
                case 4: // Golden Sunset (2000-2499m)
                    gradient.addColorStop(0, '#2e1f0d');
                    gradient.addColorStop(0.5, '#3d2d1b');
                    gradient.addColorStop(1, '#776741');
                    break;
            }

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Atmospheric depth overlay (subtly 'pushes back' the scene)
            ctx.fillStyle = 'rgba(0,0,0,0.08)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            // Draw background stars
            drawStars();

            // Draw speed tunnel streaks (motion compression)
            drawSpeedStreaks();

            // Speed-based edge vignette (tunnel compression)
            const vignetteIntensity = Math.min(0.4, (gameSpeed - 1) * 0.15);
            if (vignetteIntensity > 0) {
                const vignetteGradient = ctx.createRadialGradient(
                    CANVAS_WIDTH / 2,
                    CANVAS_HEIGHT / 2,
                    CANVAS_WIDTH * 0.3,
                    CANVAS_WIDTH / 2,
                    CANVAS_HEIGHT / 2,
                    CANVAS_WIDTH * 0.7
                );
                vignetteGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
                vignetteGradient.addColorStop(1, `rgba(0, 0, 0, ${vignetteIntensity})`);
                ctx.fillStyle = vignetteGradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            }

            // Watermark removed per user request

            // Parallax cloud layers (creates atmospheric depth)
            drawParallaxClouds();

            // Draw rocket lighting (dynamic light source)
            drawRocketLight();

            // Draw obstacles (red danger only)
            for (let obs of obstacles) {
                drawObstacle(obs);
            }

            // Draw bonuses (T26 logo powerups)
            for (let bonus of bonuses) {
                drawBonus(bonus);

                // Draw "COLLECT ME!" text above bonus
                ctx.save();
                const textY = bonus.y - bonus.height * 0.8;
                const textBounce = Math.sin(Date.now() * 0.008) * 5 * canvasScale;

                ctx.textAlign = 'center';
                ctx.font = `bold ${20 * canvasScale}px Arial`;

                // Text shadow/outline
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.lineWidth = 4 * canvasScale;
                ctx.strokeText('COLLECT ME!', bonus.x + bonus.width/2, textY + textBounce);

                // Main text with golden gradient
                const textGradient = ctx.createLinearGradient(
                    bonus.x, textY + textBounce - 10,
                    bonus.x, textY + textBounce + 10
                );
                textGradient.addColorStop(0, '#ffff00');
                textGradient.addColorStop(0.5, '#ffd700');
                textGradient.addColorStop(1, '#ffaa00');
                ctx.fillStyle = textGradient;
                ctx.fillText('COLLECT ME!', bonus.x + bonus.width/2, textY + textBounce);

                ctx.restore();
            }

            // Draw coins
            for (let coin of coins) {
                drawCoin(coin);
            }

            // Draw near-miss effects
            drawNearMisses();

            // Draw particles with fade
            for (let p of particles) {
                // Performance: skip off-screen particles
                if (p.x < -50 || p.x > CANVAS_WIDTH + 50 ||
                    p.y < -50 || p.y > CANVAS_HEIGHT + 50) {
                    continue;
                }

                ctx.save();

                // Use custom alpha if available, otherwise fade based on life
                if (p.alpha !== undefined) {
                    ctx.globalAlpha = p.alpha;
                } else {
                    ctx.globalAlpha = p.life / PARTICLE_LIFETIME;
                }

                ctx.fillStyle = p.color;

                // Use custom size if available, otherwise default
                const particleSize = p.size || (4 * canvasScale);

                // Draw with rotation if it has rotation (debris)
                if (p.rotation !== undefined) {
                    ctx.translate(p.x, p.y);
                    ctx.rotate(p.rotation);
                    ctx.fillRect(-particleSize / 2, -particleSize / 2, particleSize, particleSize);
                } else if (p.type === 'fire') {
                    // ULTRA-REALISTIC ROCKET-STYLE FLAME with turbulence
                    ctx.translate(p.x, p.y);

                    // Turbulent movement (flames dance and twist)
                    if (p.turbulence !== undefined) {
                        p.x += Math.sin(p.flickerPhase * 0.5) * p.turbulence;
                    }

                    // Rotate flames for more chaos
                    if (p.rotationSpeed !== undefined) {
                        p.rotation += p.rotationSpeed;
                        ctx.rotate(p.rotation);
                    }

                    // Animate flicker (use custom speed if available)
                    const flickerSpeed = p.flickerSpeed || 0.2;
                    p.flickerPhase += flickerSpeed;
                    const flicker = Math.sin(p.flickerPhase) * 0.2 + 1; // More dramatic flicker
                    const flickerX = Math.cos(p.flickerPhase * 0.7) * particleSize * 0.15; // More sway

                    const flameWidth = particleSize * 1.6 * flicker; // CINEMATIC - bigger core
                    const flameHeight = particleSize * 3.2 * flicker; // HEAVY fire presence

                    // Create flame gradient (hot center, cooler edges)
                    const flameGradient = ctx.createRadialGradient(
                        flickerX, flameHeight * 0.1, 0,
                        flickerX, 0, flameHeight * 0.6
                    );

                    // Gradient based on particle color (hotter = brighter)
                    if (p.color.includes('ffffff')) {
                        // White hot core
                        flameGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                        flameGradient.addColorStop(0.3, 'rgba(255, 255, 100, 0.9)');
                        flameGradient.addColorStop(0.6, 'rgba(255, 150, 0, 0.6)');
                        flameGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                    } else if (p.color.includes('ffff00')) {
                        // Yellow flame
                        flameGradient.addColorStop(0, 'rgba(255, 255, 100, 1)');
                        flameGradient.addColorStop(0.4, 'rgba(255, 200, 0, 0.8)');
                        flameGradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.5)');
                        flameGradient.addColorStop(1, 'rgba(200, 50, 0, 0)');
                    } else if (p.color.includes('ff9900')) {
                        // Orange flame
                        flameGradient.addColorStop(0, 'rgba(255, 200, 50, 1)');
                        flameGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.8)');
                        flameGradient.addColorStop(0.7, 'rgba(255, 80, 0, 0.5)');
                        flameGradient.addColorStop(1, 'rgba(150, 30, 0, 0)');
                    } else {
                        // Red/orange flame
                        flameGradient.addColorStop(0, 'rgba(255, 150, 0, 1)');
                        flameGradient.addColorStop(0.4, 'rgba(255, 80, 0, 0.9)');
                        flameGradient.addColorStop(0.7, 'rgba(200, 50, 0, 0.6)');
                        flameGradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                    }

                    ctx.fillStyle = flameGradient;

                    // LAYER 3: Outer glow (soft, large)
                    ctx.save();
                    ctx.globalAlpha = 0.3;
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = particleSize * 2.0;
                    ctx.beginPath();
                    ctx.ellipse(flickerX, 0, flameWidth * 0.7, flameHeight * 0.6, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();

                    // LAYER 2: Main flame body (organic teardrop shape)
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = particleSize * 1.5;
                    ctx.beginPath();
                    ctx.moveTo(flickerX, -flameHeight / 2);
                    ctx.bezierCurveTo(
                        flameWidth / 2.5 + flickerX * 0.5, -flameHeight / 3,
                        flameWidth / 2, 0,
                        flameWidth / 3, flameHeight / 2
                    );
                    ctx.bezierCurveTo(
                        flameWidth / 6, flameHeight / 2.5,
                        -flameWidth / 6, flameHeight / 2.5,
                        -flameWidth / 3, flameHeight / 2
                    );
                    ctx.bezierCurveTo(
                        -flameWidth / 2, 0,
                        -flameWidth / 2.5 + flickerX * 0.5, -flameHeight / 3,
                        flickerX, -flameHeight / 2
                    );
                    ctx.closePath();
                    ctx.fill();

                    // LAYER 1: Hot core (bright center)
                    ctx.shadowBlur = particleSize * 0.8;
                    const coreGradient = ctx.createRadialGradient(
                        flickerX, flameHeight * 0.2, 0,
                        flickerX, 0, flameHeight * 0.4
                    );
                    coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                    coreGradient.addColorStop(0.5, 'rgba(255, 255, 150, 0.6)');
                    coreGradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                    ctx.fillStyle = coreGradient;
                    ctx.beginPath();
                    ctx.ellipse(flickerX, 0, flameWidth * 0.3, flameHeight * 0.3, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // SMOKE particles (soft circles with blur) or regular particles
                    if (p.color.includes('666666') || p.color.includes('999999')) {
                        // Smoke - add blur
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = particleSize * 0.8;
                    }
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, particleSize / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                ctx.restore();
            }

            // Draw image-based explosions
            drawExplosions();

            // Draw player (T26 branded rocket - teal) - hide during death animation
            if (!deathAnimationActive) {
                drawRocket(player);
            }

            // Boost mode visual effect
            if (boostActive) {
                // Golden screen glow
                ctx.save();
                const boostIntensity = Math.sin(Date.now() * 0.01) * 0.1 + 0.2;
                ctx.fillStyle = `rgba(255, 215, 0, ${boostIntensity})`;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Speed lines effect
                for (let i = 0; i < 10; i++) {
                    const lineY = Math.random() * CANVAS_HEIGHT;
                    const lineLength = 100 + Math.random() * 200;
                    const lineX = CANVAS_WIDTH - (Date.now() * 0.5 % CANVAS_WIDTH);

                    ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 + Math.random() * 0.3})`;
                    ctx.lineWidth = 2 + Math.random() * 3;
                    ctx.beginPath();
                    ctx.moveTo(lineX + i * 100, lineY);
                    ctx.lineTo(lineX + i * 100 - lineLength, lineY);
                    ctx.stroke();
                }

                // "BOOST!" text
                ctx.globalAlpha = 0.8;
                ctx.textAlign = 'center';
                ctx.font = `bold ${40 * canvasScale}px Arial`;
                ctx.fillStyle = '#ffd700';
                ctx.strokeStyle = '#ff9500';
                ctx.lineWidth = 3 * canvasScale;
                ctx.fillText('BOOST!', CANVAS_WIDTH / 2, 100 * canvasScale);
                ctx.strokeText('BOOST!', CANVAS_WIDTH / 2, 100 * canvasScale);

                ctx.restore();
            }

            // Branded title fade-in (classy product moment at game start)
            if (titleFadeActive && titleFadeOpacity > 0) {
                ctx.globalAlpha = titleFadeOpacity;
                ctx.fillStyle = '#26a69a';
                ctx.font = `bold ${48 * canvasScale}px Arial`; // Scaled font
                ctx.textAlign = 'center';
                ctx.fillText('T26 RUNNER', CANVAS_WIDTH / 2, 90 * canvasScale);
                ctx.globalAlpha = 1;
            }

            // Milestone celebration message
            if (celebrationActive && celebrationOpacity > 0) {
                ctx.save();
                ctx.globalAlpha = celebrationOpacity;
                ctx.textAlign = 'center';

                // Outer glow effect
                ctx.shadowColor = '#ffd700';
                ctx.shadowBlur = 30 * canvasScale;

                // Main text with gradient
                const textGradient = ctx.createLinearGradient(
                    CANVAS_WIDTH / 2 - 200 * canvasScale,
                    0,
                    CANVAS_WIDTH / 2 + 200 * canvasScale,
                    0
                );
                textGradient.addColorStop(0, '#ffd700');
                textGradient.addColorStop(0.5, '#ffed4e');
                textGradient.addColorStop(1, '#ffd700');

                ctx.fillStyle = textGradient;
                ctx.font = `bold ${(60 * celebrationScale) * canvasScale}px Arial`;
                ctx.fillText(celebrationMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 3);

                // Stroke for emphasis
                ctx.strokeStyle = '#ff6b00';
                ctx.lineWidth = 3 * canvasScale;
                ctx.strokeText(celebrationMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 3);

                ctx.restore();
            }

            // Zone transition message
            if (zoneTransitionActive && zoneTransitionOpacity > 0) {
                ctx.save();
                ctx.globalAlpha = zoneTransitionOpacity;
                ctx.textAlign = 'center';

                // Outer glow effect
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 25 * canvasScale;

                // Main text
                ctx.fillStyle = '#00ffff';
                ctx.font = `bold ${35 * canvasScale}px Arial`;
                ctx.fillText(zoneTransitionMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);

                // Stroke for emphasis
                ctx.strokeStyle = '#0088ff';
                ctx.lineWidth = 2 * canvasScale;
                ctx.strokeText(zoneTransitionMessage, CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);

                ctx.restore();
            }
        }

        function drawRocketLight() {
            // Dynamic orange light emanating from rocket (boosted with fxIntensity + proximity)
            const lightRadius = (80 + gameSpeed * 20) * canvasScale;
            const baseIntensity = 0.12 + (gameSpeed / 10) * 0.08;
            const lightIntensity = baseIntensity * fxIntensity.rocket * 0.85; // 15% reduction + fxIntensity

            const lightGradient = ctx.createRadialGradient(
                player.x + player.width / 2,
                player.y + player.height / 2,
                0,
                player.x + player.width / 2,
                player.y + player.height / 2,
                lightRadius
            );
            lightGradient.addColorStop(0, `rgba(255, 149, 0, ${lightIntensity})`);
            lightGradient.addColorStop(0.5, `rgba(255, 149, 0, ${lightIntensity * 0.4})`);
            lightGradient.addColorStop(1, 'rgba(255, 149, 0, 0)');

            ctx.fillStyle = lightGradient;
            ctx.fillRect(
                player.x + player.width / 2 - lightRadius,
                player.y + player.height / 2 - lightRadius,
                lightRadius * 2,
                lightRadius * 2
            );
        }

        function drawRocket(rocket) {
            ctx.save();

 

            // Flame physics calculations
            const time = performance.now() * 0.001; // Smooth time for oscillations
            const thrustFactor = (rocket.thrustBoost || 1.0); // Boost flames when thrusting forward
            const speedFactor = (1 + (gameSpeed - 1) * 0.3) * thrustFactor; // Stretch flames with speed + thrust
            const velocityBend = player.velocityY * 0.8; // Bend opposite to movement

            // Smooth oscillation (replace Math.random with sine waves)
            const flameWave = Math.sin(time * 8) * 2 * canvasScale;
            const flameWave2 = Math.sin(time * 10 + 1.5) * 1.5 * canvasScale;

            // Top engine flame (upper thruster) - positioned very close to rocket body
            const topEngineY = rocket.y + rocket.height * 0.38; // 38% down from top

            // Bottom engine flame (lower thruster) - positioned very close to rocket body
            const bottomEngineY = rocket.y + rocket.height * 0.62; // 62% down from top

            // Draw both engine flames (top and bottom thrusters)
            [topEngineY, bottomEngineY].forEach((engineY, index) => {
                const waveOffset = index === 0 ? flameWave : flameWave2;

                // LAYER 3: Exhaust Glow (largest, softest, drawn first/behind) - BIGGER
                const glowLength = (55 + speedFactor * 18) * canvasScale; // Increased from 35+10 to 55+18
                const glowWidth = 28 * canvasScale; // Increased from 18 to 28
                const flameAnchorX = rocket.x + rocket.width * 0.35; // Position flames closer to center of rocket (35% from left)

                // Add blue tint when moving fast
                const blueIntensity = Math.min((thrustFactor - 1) * 0.4, 0.3); // Blue when moving

                ctx.save();
                const glowIntensity = 0.5 * thrustFactor;
                ctx.shadowColor = `rgba(255, 140, 0, ${glowIntensity})`;
                ctx.shadowBlur = 60 * canvasScale * thrustFactor; // Increased from 40

                const glowGradient = ctx.createLinearGradient(
                    flameAnchorX, engineY,
                    flameAnchorX - glowLength + velocityBend, engineY + waveOffset
                );
                // Mix blue when moving fast
                glowGradient.addColorStop(0, `rgba(255, ${180 - blueIntensity * 100}, ${100 + blueIntensity * 155}, ${0.5 * thrustFactor})`);
                glowGradient.addColorStop(0.6, `rgba(255, 100, ${blueIntensity * 100}, ${0.2 * thrustFactor})`);
                glowGradient.addColorStop(1, 'rgba(255, 80, 0, 0)');

                ctx.fillStyle = glowGradient;
                ctx.beginPath();
                ctx.ellipse(
                    flameAnchorX - glowLength/2 + velocityBend,
                    engineY + waveOffset,
                    glowLength/2,
                    glowWidth/2,
                    0, 0, Math.PI * 2
                );
                ctx.fill();
                ctx.restore();

                // LAYER 2: Mid Flame (orange gradient, teardrop geometry) - BIGGER
                const midLength = (35 + speedFactor * 14) * canvasScale; // Increased from 22+8 to 35+14
                const midWidth = 16 * canvasScale; // Increased from 10 to 16

                const midGradient = ctx.createLinearGradient(
                    flameAnchorX, engineY,
                    flameAnchorX - midLength + velocityBend, engineY + waveOffset * 0.7
                );
                midGradient.addColorStop(0, '#ffb366'); // Bright orange
                midGradient.addColorStop(0.4, '#ff8c1a'); // Mid orange
                midGradient.addColorStop(1, 'rgba(255, 100, 0, 0)'); // Fade to transparent

                ctx.fillStyle = midGradient;
                ctx.beginPath();
                // Teardrop shape (anchored near left edge of rocket)
                ctx.moveTo(flameAnchorX, engineY - midWidth/2);
                ctx.quadraticCurveTo(
                    flameAnchorX - midLength/2 + velocityBend,
                    engineY + waveOffset * 0.7 - midWidth/2,
                    flameAnchorX - midLength + velocityBend,
                    engineY + waveOffset * 0.7
                );
                ctx.quadraticCurveTo(
                    flameAnchorX - midLength/2 + velocityBend,
                    engineY + waveOffset * 0.7 + midWidth/2,
                    flameAnchorX,
                    engineY + midWidth/2
                );
                ctx.closePath();
                ctx.fill();

                // LAYER 1: Core Flame (white-hot, short, stable - minimal variation) - BIGGER
                const coreLength = (18 + speedFactor * 6) * canvasScale; // Increased from 10+3 to 18+6
                const coreWidth = 8 * canvasScale; // Increased from 5 to 8
                const coreWave = Math.sin(time * 12 + index) * 0.5 * canvasScale; // Very subtle

                const coreGradient = ctx.createLinearGradient(
                    flameAnchorX, engineY,
                    flameAnchorX - coreLength + velocityBend * 0.3, engineY + coreWave
                );
                coreGradient.addColorStop(0, '#ffffff'); // White-hot center
                coreGradient.addColorStop(0.3, '#fffacd'); // Pale yellow
                coreGradient.addColorStop(1, 'rgba(255, 200, 100, 0)'); // Fade out

                ctx.fillStyle = coreGradient;
                ctx.beginPath();
                // Small teardrop, anchored near left edge of rocket
                ctx.moveTo(flameAnchorX, engineY - coreWidth/2);
                ctx.quadraticCurveTo(
                    flameAnchorX - coreLength/2 + velocityBend * 0.3,
                    engineY + coreWave - coreWidth/2,
                    flameAnchorX - coreLength + velocityBend * 0.3,
                    engineY + coreWave
                );
                ctx.quadraticCurveTo(
                    flameAnchorX - coreLength/2 + velocityBend * 0.3,
                    engineY + coreWave + coreWidth/2,
                    flameAnchorX,
                    engineY + coreWidth/2
                );
                ctx.closePath();
                ctx.fill();
            });

            // Draw T26 logo (use transparent version)
            if (images.logoIcon.complete && images.logoIcon.naturalHeight !== 0) {
                // Draw logo at rocket position with slight glow effect
                ctx.shadowColor = 'rgba(255, 149, 0, 0.6)';
                ctx.shadowBlur = 15;
                ctx.drawImage(images.logoIcon, rocket.x, rocket.y, rocket.width, rocket.height);
                ctx.shadowBlur = 0;
            } else {
                // Fallback: simple rocket shape if image hasn't loaded
                ctx.fillStyle = '#ff9500';
                ctx.beginPath();
                ctx.moveTo(rocket.x + rocket.width/2, rocket.y);
                ctx.lineTo(rocket.x, rocket.y + rocket.height * 0.6);
                ctx.lineTo(rocket.x + rocket.width/4, rocket.y + rocket.height);
                ctx.lineTo(rocket.x + rocket.width * 0.75, rocket.y + rocket.height);
                ctx.lineTo(rocket.x + rocket.width, rocket.y + rocket.height * 0.6);
                ctx.closePath();
                ctx.fill();
            }

            ctx.restore();
        }

        function drawCloudPlatform(platform) {
            // Off-white, not pure white (more environment, less UI)
            ctx.fillStyle = 'rgba(235, 240, 245, 0.85)';
            ctx.shadowColor = 'rgba(0, 0, 0, 0.1)';
            ctx.shadowBlur = 10;

            // Cloud-like platform with organic variation (NOT uniform row)
            const cloudParts = 5;
            const partWidth = platform.width / cloudParts;

            for (let i = 0; i < cloudParts; i++) {
                // Each cloud part varies slightly (breaks uniformity)
                const sizeVariation = 1 + (Math.sin(platform.x * 0.05 + i) * 0.15);
                const yOffset = Math.sin(platform.x * 0.03 + i * 1.5) * 8;
                const radius = (partWidth / 2) * sizeVariation;

                ctx.globalAlpha = 0.85 + (Math.sin(platform.x * 0.02 + i) * 0.12);
                ctx.beginPath();
                ctx.arc(
                    platform.x + i * partWidth + partWidth/2,
                    platform.y + 10 + yOffset,
                    radius,
                    0,
                    Math.PI * 2
                );
                ctx.fill();
            }

            ctx.globalAlpha = 1;
            ctx.shadowBlur = 0;
        }

        // Optimized parallax clouds (performance + depth perception) - scaled dynamically
        function drawParallaxClouds() {
            // Update offsets (incremental, not Date.now() allocation)
            cloudOffsetSlow += 0.4 * canvasScale;
            cloudOffsetFast += 1.0 * canvasScale;

            // Back layer (slow, faint) - far away atmosphere
            ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
            const cloudYBack = [80, 220, 140, 320, 180, 400].map(y => y * canvasScale);

            for (let i = 0; i < 6; i++) {
                const x = (cloudOffsetSlow * (1 + i * 0.3)) % (1400 * canvasScale);
                ctx.beginPath();
                ctx.arc(x, cloudYBack[i], 50 * canvasScale, 0, Math.PI * 2);
                ctx.arc(x + 45 * canvasScale, cloudYBack[i], 55 * canvasScale, 0, Math.PI * 2);
                ctx.arc(x + 90 * canvasScale, cloudYBack[i], 50 * canvasScale, 0, Math.PI * 2);
                ctx.fill();
            }

            // Front layer (faster, brighter) - closer atmosphere
            ctx.fillStyle = 'rgba(255, 255, 255, 0.18)';
            const cloudYFront = [110, 260, 170, 360, 210, 450].map(y => y * canvasScale);

            for (let i = 0; i < 6; i++) {
                const x = (cloudOffsetFast * (1 + i * 0.4)) % (1400 * canvasScale);
                ctx.beginPath();
                ctx.arc(x, cloudYFront[i], 42 * canvasScale, 0, Math.PI * 2);
                ctx.arc(x + 38 * canvasScale, cloudYFront[i], 48 * canvasScale, 0, Math.PI * 2);
                ctx.arc(x + 75 * canvasScale, cloudYFront[i], 42 * canvasScale, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ============================================================
        // OBSTACLE CONTRAST HALO - Ensures readability against backgrounds
        // ============================================================
        function drawObstacle(obs) {

            // Spawn animation (fade/scale-in) - prevents sudden appearance
            const spawnProgress = Math.min(1, obs.age / 15); // 15 frames to full visibility
            const spawnAlpha = spawnProgress; // Fade from 0 to 1

            ctx.save();
            ctx.globalAlpha = spawnAlpha;

            if (obs.type === 'candlestick') {
                // Real market candlestick with vertical gradient (darker base = threat language)
                // Add subtle pulse animation
                const pulse = Math.sin(Date.now() * 0.003 + obs.y) * 0.03 + 1;
                const centerX = obs.x + 25 * canvasScale;

                // Wick (thin line)
                ctx.strokeStyle = `rgba(139, 0, 0, ${0.8 + pulse * 0.2})`;
                ctx.lineWidth = 2 * canvasScale;
                ctx.beginPath();
                ctx.moveTo(centerX, obs.y - 15 * canvasScale);
                ctx.lineTo(centerX, obs.y + obs.height + 15 * canvasScale);
                ctx.stroke();

                // Body with vertical gradient (darker at bottom = danger/threat)
                const gradient = ctx.createLinearGradient(0, obs.y, 0, obs.y + obs.height);
                gradient.addColorStop(0, '#ff6b6b'); // Lighter top
                gradient.addColorStop(1, '#8b0000'); // Darker bottom (threat language)

                ctx.fillStyle = gradient;
                ctx.fillRect(obs.x + 15 * canvasScale, obs.y, 20 * canvasScale, obs.height);

                // Subtle border for definition
                ctx.strokeStyle = 'rgba(139, 0, 0, 0.8)';
                ctx.lineWidth = 1 * canvasScale;
                ctx.strokeRect(obs.x + 15 * canvasScale, obs.y, 20 * canvasScale, obs.height);

                // Glow effect for modern look (reduced 15% + fxIntensity)
                const candleGlowAlpha = 0.5 * 0.85 * fxIntensity.obstacles;
                ctx.shadowColor = `rgba(255, 0, 0, ${candleGlowAlpha})`;
                ctx.shadowBlur = 10 * canvasScale;
                ctx.strokeRect(obs.x + 15 * canvasScale, obs.y, 20 * canvasScale, obs.height);
                ctx.shadowBlur = 0;
            } else if (obs.type === 'bitcoin') {
                // Bitcoin logo image
                if (images.bitcoin.complete && images.bitcoin.naturalHeight !== 0) {
                    const breathe = Math.sin(Date.now() * 0.002 + obs.x * 0.01) * 0.05 + 1;

                    ctx.save();
                    ctx.translate(obs.x + obs.width/2, obs.y + obs.height/2);
                    ctx.scale(breathe, breathe);
                    ctx.rotate(obs.rotation);

                    // Draw image centered
                    ctx.drawImage(images.bitcoin, -obs.width/2, -obs.height/2, obs.width, obs.height);

                    ctx.restore();
                }
            } else if (obs.type === 'ethereum') {
                // Ethereum logo image
                if (images.ethereum.complete && images.ethereum.naturalHeight !== 0) {
                    const breathe = Math.sin(Date.now() * 0.0025 + obs.y * 0.01) * 0.04 + 1;

                    ctx.save();
                    ctx.translate(obs.x + obs.width/2, obs.y + obs.height/2);
                    ctx.scale(breathe, breathe);

                    // Draw image centered
                    ctx.drawImage(images.ethereum, -obs.width/2, -obs.height/2, obs.width, obs.height);

                    ctx.restore();
                }
            } else if (obs.type === 'solana') {
                // Solana logo image
                if (images.solana.complete && images.solana.naturalHeight !== 0) {
                    const breathe = Math.sin(Date.now() * 0.002 + obs.x * 0.01) * 0.05 + 1;

                    ctx.save();
                    ctx.translate(obs.x + obs.width/2, obs.y + obs.height/2);
                    ctx.scale(breathe, breathe);
                    ctx.rotate(obs.rotation);

                    // Draw image centered
                    ctx.drawImage(images.solana, -obs.width/2, -obs.height/2, obs.width, obs.height);

                    ctx.restore();
                }
            } else if (obs.type === 'shib') {
                // Shiba Inu logo image
                if (images.shib.complete && images.shib.naturalHeight !== 0) {
                    const pulseScale = Math.sin(obs.pulse) * 0.06 + 1;

                    ctx.save();
                    ctx.translate(obs.x + obs.width/2, obs.y + obs.height/2);
                    ctx.scale(pulseScale, pulseScale);

                    // Draw image centered
                    ctx.drawImage(images.shib, -obs.width/2, -obs.height/2, obs.width, obs.height);

                    ctx.restore();
                }
            } else if (obs.type === 'bnb') {
                // BNB logo image
                if (images.bnb.complete && images.bnb.naturalHeight !== 0) {
                    const breathe = Math.sin(Date.now() * 0.0022 + obs.y * 0.01) * 0.04 + 1;

                    ctx.save();
                    ctx.translate(obs.x + obs.width/2, obs.y + obs.height/2);
                    ctx.scale(breathe, breathe);
                    ctx.rotate(obs.rotation);

                    // Draw image centered
                    ctx.drawImage(images.bnb, -obs.width/2, -obs.height/2, obs.width, obs.height);

                    ctx.restore();
                }
            }

            ctx.restore();
        }


        function drawBonus(bonus) {
            ctx.save();

            // Translate to center for rotation
            ctx.translate(bonus.x + bonus.width/2, bonus.y + bonus.height/2);
            ctx.rotate(bonus.rotation);

            // LARGE pulsing outer glow rings (animated)
            const time = Date.now() * 0.003;
            const ring1 = Math.sin(time) * 0.3 + 1.8;
            const ring2 = Math.sin(time + Math.PI/2) * 0.3 + 2.2;

            // First ring - bright golden
            const glow1 = ctx.createRadialGradient(0, 0, 0, 0, 0, bonus.width * ring1);
            glow1.addColorStop(0, 'rgba(255, 215, 0, 0.4)');
            glow1.addColorStop(0.3, 'rgba(255, 149, 0, 0.3)');
            glow1.addColorStop(1, 'rgba(255, 149, 0, 0)');
            ctx.fillStyle = glow1;
            ctx.beginPath();
            ctx.arc(0, 0, bonus.width * ring1, 0, Math.PI * 2);
            ctx.fill();

            // Second ring - orange
            const glow2 = ctx.createRadialGradient(0, 0, 0, 0, 0, bonus.width * ring2);
            glow2.addColorStop(0, 'rgba(255, 100, 0, 0.3)');
            glow2.addColorStop(0.3, 'rgba(255, 50, 0, 0.2)');
            glow2.addColorStop(1, 'rgba(255, 50, 0, 0)');
            ctx.fillStyle = glow2;
            ctx.beginPath();
            ctx.arc(0, 0, bonus.width * ring2, 0, Math.PI * 2);
            ctx.fill();

            // Bright border ring (solid circle behind logo)
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.9)';
            ctx.lineWidth = 6 * canvasScale;
            ctx.shadowColor = '#ffd700';
            ctx.shadowBlur = 30 * canvasScale;
            ctx.beginPath();
            ctx.arc(0, 0, bonus.width * 0.6, 0, Math.PI * 2);
            ctx.stroke();
            ctx.shadowBlur = 0;

            // Inner bright background circle
            const innerGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, bonus.width * 0.55);
            innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
            innerGlow.addColorStop(0.5, 'rgba(255, 215, 0, 0.2)');
            innerGlow.addColorStop(1, 'rgba(255, 149, 0, 0)');
            ctx.fillStyle = innerGlow;
            ctx.beginPath();
            ctx.arc(0, 0, bonus.width * 0.55, 0, Math.PI * 2);
            ctx.fill();

            // Draw T26 logo with STRONGER pulsing effect (larger)
            const pulse = Math.sin(Date.now() * 0.006) * 0.25 + 1.15;
            const size = bonus.width * pulse;

            if (images.logoTransparent.complete && images.logoTransparent.naturalHeight !== 0) {
                ctx.shadowColor = 'rgba(255, 255, 255, 1)';
                ctx.shadowBlur = 40 * canvasScale;
                ctx.drawImage(images.logoTransparent, -size/2, -size/2, size, size);
                ctx.shadowBlur = 0;
            } else {
                // Fallback: draw golden circle
                ctx.fillStyle = '#ffd700';
                ctx.beginPath();
                ctx.arc(0, 0, size/2, 0, Math.PI * 2);
                ctx.fill();
            }

            ctx.restore();
        }


        function drawCoin(coin) {
            ctx.save();

            // Floating animation
            const floatY = coin.y + Math.sin(coin.floatOffset) * 8 * canvasScale;

            // Translate to center for rotation
            ctx.translate(coin.x + coin.width/2, floatY + coin.height/2);

            // Rotation effect (coin spinning)
            const spinScale = Math.abs(Math.cos(coin.rotation));
            ctx.scale(spinScale, 1);

            // Outer glow
            const glowGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, coin.width * 1.2);
            glowGradient.addColorStop(0, 'rgba(255, 215, 0, 0.5)');
            glowGradient.addColorStop(0.5, 'rgba(255, 215, 0, 0.2)');
            glowGradient.addColorStop(1, 'rgba(255, 215, 0, 0)');
            ctx.fillStyle = glowGradient;
            ctx.beginPath();
            ctx.arc(0, 0, coin.width * 1.2, 0, Math.PI * 2);
            ctx.fill();

            // Main coin circle (golden)
            const coinGradient = ctx.createRadialGradient(
                -coin.width * 0.2, -coin.height * 0.2, 0,
                0, 0, coin.width * 0.8
            );
            coinGradient.addColorStop(0, '#ffff99');
            coinGradient.addColorStop(0.3, '#ffd700');
            coinGradient.addColorStop(0.7, '#ffaa00');
            coinGradient.addColorStop(1, '#cc8800');
            ctx.fillStyle = coinGradient;
            ctx.beginPath();
            ctx.arc(0, 0, coin.width / 2, 0, Math.PI * 2);
            ctx.fill();

            // Coin border
            ctx.strokeStyle = '#cc8800';
            ctx.lineWidth = 2 * canvasScale;
            ctx.stroke();

            // Inner circle detail
            ctx.strokeStyle = '#ffcc00';
            ctx.lineWidth = 1.5 * canvasScale;
            ctx.beginPath();
            ctx.arc(0, 0, coin.width * 0.35, 0, Math.PI * 2);
            ctx.stroke();

            // "T" symbol in center
            ctx.fillStyle = '#cc8800';
            ctx.font = `bold ${coin.width * 0.5}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('T', 0, 0);

            ctx.restore();
        }

        function spawnObstaclePattern() {
            // Shuffle patterns when cycling back to prevent predictability
            if (patternIndex === 0) {
                OBSTACLE_PATTERNS.sort(() => Math.random() - 0.5);
            }

            // Get current pattern
            const pattern = OBSTACLE_PATTERNS[patternIndex];
            patternIndex = (patternIndex + 1) % OBSTACLE_PATTERNS.length;

            // Lane positions (dynamically scaled)
            const lanePositions = {
                'left': 80 * canvasScale,
                'center': CANVAS_WIDTH/2 - 40 * canvasScale,
                'right': CANVAS_WIDTH - 180 * canvasScale
            };

            // Spawn obstacles according to pattern - mixed obstacle types
            pattern.forEach((laneName, index) => {
                const laneX = lanePositions[laneName];

                // Random vertical positions throughout the screen (scaled)
                const minObstacleY = 100 * canvasScale;
                const maxObstacleY = CANVAS_HEIGHT - 200 * canvasScale;
                const randomY = minObstacleY + Math.random() * (maxObstacleY - minObstacleY);

                // Select random obstacle type - crypto themed
                const types = ['candlestick', 'bitcoin', 'ethereum', 'solana', 'shib', 'bnb'];
                const type = types[Math.floor(Math.random() * types.length)];

                let obstacle = {
                    x: CANVAS_WIDTH + 150 * canvasScale + (index * 200 * canvasScale), // Spawn further off-screen, more stagger
                    y: randomY,
                    type: type
                };

                switch(type) {
                    case 'candlestick':
                        obstacle.width = 70 * canvasScale;
                        obstacle.height = (70 + Math.random() * 60) * canvasScale; // Random height 70-130px
                        break;
                    case 'bitcoin':
                        obstacle.width = 65 * canvasScale;
                        obstacle.height = 65 * canvasScale;
                        obstacle.rotation = Math.random() * Math.PI * 2;
                        obstacle.rotationSpeed = 0.03 + Math.random() * 0.04; // Slower, smoother rotation
                        break;
                    case 'ethereum':
                        obstacle.width = 70 * canvasScale;
                        obstacle.height = 70 * canvasScale;
                        obstacle.originalY = randomY; // Store original Y position
                        obstacle.driftOffset = 0;
                        obstacle.driftSpeed = 0.025 + Math.random() * 0.025; // Floating effect
                        break;
                    case 'solana':
                        obstacle.width = 65 * canvasScale;
                        obstacle.height = 65 * canvasScale;
                        obstacle.rotation = Math.random() * Math.PI * 2;
                        obstacle.rotationSpeed = 0.02 + Math.random() * 0.03;
                        break;
                    case 'shib':
                        obstacle.width = 65 * canvasScale;
                        obstacle.height = 65 * canvasScale;
                        obstacle.pulse = 0;
                        obstacle.pulseSpeed = 0.04 + Math.random() * 0.03;
                        break;
                    case 'bnb':
                        obstacle.width = 65 * canvasScale;
                        obstacle.height = 65 * canvasScale;
                        obstacle.rotation = Math.random() * Math.PI * 2;
                        obstacle.rotationSpeed = 0.015 + Math.random() * 0.025;
                        break;
                }

                obstacles.push(obstacle);
            });
        }

        function checkCollision(rect1, rect2) {
            // Add small padding (10%) to make collisions more forgiving
            const padding = 5 * canvasScale;
            return rect1.x + padding < rect2.x + rect2.width - padding &&
                   rect1.x + rect1.width - padding > rect2.x + padding &&
                   rect1.y + padding < rect2.y + rect2.height - padding &&
                   rect1.y + rect1.height - padding > rect2.y + padding;
        }

 
        function spawnBonus() {
            const bonusSize = 50 * canvasScale;
            const minY = 100 * canvasScale;
            const maxY = CANVAS_HEIGHT - 150 * canvasScale;
            const randomY = minY + Math.random() * (maxY - minY);

            bonuses.push({
                x: CANVAS_WIDTH + 100 * canvasScale,
                y: randomY,
                width: bonusSize,
                height: bonusSize,
                rotation: 0
            });
        }

        function collectBonus(index) {
            const bonus = bonuses[index];

            // Activate boost mode
            boostActive = true;
            boostDuration = BOOST_DURATION_FRAMES;

            // Add bonus points
            distance += BONUS_POINTS;

            // Create confetti burst (golden)
            const x = bonus.x + bonus.width/2;
            const y = bonus.y + bonus.height/2;
            createParticles(x, y, '#ffd700', 20);  // Gold
            createParticles(x, y, '#ff9500', 15);  // Orange
            createParticles(x, y, '#ffff00', 12);  // Yellow

            // Play boost sound
            if (audioEnabled) {
                playAudioFile('boost');
            }

            // Remove bonus
            bonuses.splice(index, 1);
        }

        function spawnCoin() {
            const coinSize = 25 * canvasScale;
            const minY = 80 * canvasScale;
            const maxY = CANVAS_HEIGHT - 120 * canvasScale;
            const randomY = minY + Math.random() * (maxY - minY);

            coins.push({
                x: CANVAS_WIDTH + 100 * canvasScale,
                y: randomY,
                width: coinSize,
                height: coinSize,
                rotation: 0,
                floatOffset: Math.random() * Math.PI * 2
            });
        }

        function collectCoin(index) {
            const coin = coins[index];

            // Add points for coin collection
            const COIN_VALUE = 10;
            distance += COIN_VALUE;
            totalCoins++;

            // Create confetti sparkle particles (golden)
            const x = coin.x + coin.width/2;
            const y = coin.y + coin.height/2;
            createParticles(x, y, '#ffff00', 8);
            createParticles(x, y, '#ffd700', 6);

            // Play coin sound
            if (audioEnabled) {
                playAudioFile('coin');
            }

            // Remove coin
            coins.splice(index, 1);
        }

      
        function spawnExplosion(x, y, scale = 1) {
            explosions.push({
                x: x,
                y: y,
                scale: 0.1 * scale,      // Start small
                targetScale: 1.2 * scale, // Grow to this size
                alpha: 1,                 // Start fully visible
                rotation: Math.random() * Math.PI * 2, // Random rotation
                frame: 0,                 // Animation frame counter
                maxFrames: 40             // Total animation duration (frames)
            });
        }

        // Update and render all active explosions
        function updateExplosions() {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const exp = explosions[i];
                exp.frame++;

                // Scale up quickly, then slow down
                const scaleProgress = Math.min(exp.frame / 15, 1); // Scale up over 15 frames
                exp.scale = exp.scale + (exp.targetScale - exp.scale) * 0.15;

                // Fade out in the last half of animation
                if (exp.frame > exp.maxFrames / 2) {
                    exp.alpha = 1 - ((exp.frame - exp.maxFrames / 2) / (exp.maxFrames / 2));
                }

                // Slight rotation for variation
                exp.rotation += 0.02;

                // Remove when animation complete
                if (exp.frame >= exp.maxFrames) {
                    explosions.splice(i, 1);
                }
            }
        }

        function drawExplosions() {
            for (const exp of explosions) {
                ctx.save();
                ctx.translate(exp.x, exp.y);
                ctx.rotate(exp.rotation);
                ctx.globalAlpha = exp.alpha;

                const size = 200 * canvasScale * exp.scale; // Explosion image size
                ctx.drawImage(images.explosion, -size / 2, -size / 2, size, size);

                ctx.restore();
            }
        }

        function createParticles(x, y, color, count) {
            // Performance: limit particle count
            if (particles.length >= MAX_PARTICLES) return;

            const particlesToCreate = Math.min(count, MAX_PARTICLES - particles.length);

            for (let i = 0; i < particlesToCreate; i++) {
                // Radial explosion pattern with varied speeds
                const angle = (Math.PI * 2 * i) / particlesToCreate + Math.random() * 0.5;
                const speed = (3 + Math.random() * 8) * canvasScale;

                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: color,
                    life: 30 + Math.random() * 20  // Varied lifetime for depth
                });
            }
        }

        // Note: createExplosionParticles and createDebrisParticles removed - now using image-based explosions


        function endGame() {
            if (deathAnimationActive) return; // Prevent multiple triggers
            deathAnimationActive = true;

            playDeathSound();
            stopJetEngine(); // Stop jet engine sound
            stopGameLoop(); // Clean up RAF immediately

            // 150ms input lock prevents accidental restart spam
            inputLocked = true;
            setTimeout(() => inputLocked = false, 500);

            // Brief slow-motion effect (200ms)
            slowMotionFactor = 0.3;
            setTimeout(() => {
                slowMotionFactor = 1;
                gameRunning = false;

                // Show game over screen with stats
                document.getElementById('finalDistance').textContent = Math.floor(distance);
                document.getElementById('maxSpeed').textContent = maxSpeedReached.toFixed(1);
                document.getElementById('finalCoins').textContent = totalCoins;

                // Clear previous name input
                document.getElementById('playerNameInput').value = '';

                // Save score initially as Anonymous, will update when name is entered
                saveScore(distance, maxSpeedReached, '');
                displayLeaderboard();

                // Red flash effect
                canvas.style.filter = 'saturate(0) brightness(1.5)';
                setTimeout(() => {
                    canvas.style.filter = 'saturate(0.3) brightness(0.8)';
                }, 50);

                setTimeout(() => {
                    document.getElementById('gameOver').style.display = 'block';
                    canvas.style.filter = '';
                }, 400);

            }, 200);

            // Create rocket explosion
            spawnExplosion(
                player.x + player.width/2,
                player.y + player.height/2,
                1.5  // Larger explosion for rocket death
            );

            // Continue drawing death animation using RAF (not setInterval)
            let deathFrames = 0;
            const maxDeathFrames = 30;

            function drawDeathAnimation() {
                if (!deathAnimationActive) return; // Guard: only draw if death is active

                // Dark gradient background
                const gradient = ctx.createLinearGradient(0, 0, 0, CANVAS_HEIGHT);
                gradient.addColorStop(0, '#0d1b2a');
                gradient.addColorStop(0.5, '#1b263b');
                gradient.addColorStop(1, '#415a77');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                // Fade to desaturated
                ctx.filter = `saturate(${Math.max(0, 1 - deathFrames / maxDeathFrames)})`;

                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;

                    // Apply gravity if particle has it
                    if (p.gravity !== undefined) {
                        p.vy += p.gravity;
                    } else {
                        p.vy += 0.3 * canvasScale;
                    }

                    // SMOKE RISES (buoyancy effect for realism)
                    if (p.type === 'smoke') {
                        p.vy -= 0.05 * canvasScale; // Smoke rises slowly
                    }

                    // Update rotation for debris
                    if (p.rotation !== undefined && p.rotationSpeed !== undefined) {
                        p.rotation += p.rotationSpeed;
                    }

                    // FIRE FADES FAST - smoke dominates after 10-15 frames
                    if (p.type === 'fire' && p.maxLife && p.life < p.maxLife * 0.6) {
                        if (p.alpha !== undefined) {
                            p.alpha *= 0.92; // Accelerated fade for fire
                        }
                    }

                    // Fade out smoke and fire over time
                    if (p.alpha !== undefined) {
                        p.alpha = p.life / 70;
                    }

                    p.life--;

                    // Draw particle
                    ctx.save();

                    // Use custom alpha if available
                    if (p.alpha !== undefined) {
                        ctx.globalAlpha = p.alpha;
                    } else {
                        ctx.globalAlpha = p.life / PARTICLE_LIFETIME;
                    }

                    ctx.fillStyle = p.color;

                    // Use custom size if available
                    const particleSize = p.size || (4 * canvasScale);

                    // Draw with rotation if it has rotation (debris)
                    if (p.rotation !== undefined) {
                        ctx.translate(p.x, p.y);
                        ctx.rotate(p.rotation);
                        ctx.fillRect(-particleSize / 2, -particleSize / 2, particleSize, particleSize);
                    } else if (p.type === 'fire') {
                        // ULTRA-REALISTIC ROCKET-STYLE FLAME with turbulence
                        ctx.translate(p.x, p.y);

                        // Turbulent movement (flames dance and twist)
                        if (p.turbulence !== undefined) {
                            p.x += Math.sin(p.flickerPhase * 0.5) * p.turbulence;
                        }

                        // Rotate flames for more chaos
                        if (p.rotationSpeed !== undefined) {
                            p.rotation += p.rotationSpeed;
                            ctx.rotate(p.rotation);
                        }

                        // Animate flicker (use custom speed if available)
                        const flickerSpeed = p.flickerSpeed || 0.2;
                        p.flickerPhase += flickerSpeed;
                        const flicker = Math.sin(p.flickerPhase) * 0.2 + 1; // More dramatic flicker
                        const flickerX = Math.cos(p.flickerPhase * 0.7) * particleSize * 0.15; // More sway

                        const flameWidth = particleSize * 1.6 * flicker; // CINEMATIC - bigger core
                        const flameHeight = particleSize * 3.2 * flicker; // HEAVY fire presence

                        // Create flame gradient (hot center, cooler edges)
                        const flameGradient = ctx.createRadialGradient(
                            flickerX, flameHeight * 0.1, 0,
                            flickerX, 0, flameHeight * 0.6
                        );

                        // Gradient based on particle color (hotter = brighter)
                        if (p.color.includes('ffffff')) {
                            // White hot core
                            flameGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                            flameGradient.addColorStop(0.3, 'rgba(255, 255, 100, 0.9)');
                            flameGradient.addColorStop(0.6, 'rgba(255, 150, 0, 0.6)');
                            flameGradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
                        } else if (p.color.includes('ffff00')) {
                            // Yellow flame
                            flameGradient.addColorStop(0, 'rgba(255, 255, 100, 1)');
                            flameGradient.addColorStop(0.4, 'rgba(255, 200, 0, 0.8)');
                            flameGradient.addColorStop(0.7, 'rgba(255, 100, 0, 0.5)');
                            flameGradient.addColorStop(1, 'rgba(200, 50, 0, 0)');
                        } else if (p.color.includes('ff9900')) {
                            // Orange flame
                            flameGradient.addColorStop(0, 'rgba(255, 200, 50, 1)');
                            flameGradient.addColorStop(0.4, 'rgba(255, 150, 0, 0.8)');
                            flameGradient.addColorStop(0.7, 'rgba(255, 80, 0, 0.5)');
                            flameGradient.addColorStop(1, 'rgba(150, 30, 0, 0)');
                        } else {
                            // Red/orange flame
                            flameGradient.addColorStop(0, 'rgba(255, 150, 0, 1)');
                            flameGradient.addColorStop(0.4, 'rgba(255, 80, 0, 0.9)');
                            flameGradient.addColorStop(0.7, 'rgba(200, 50, 0, 0.6)');
                            flameGradient.addColorStop(1, 'rgba(100, 0, 0, 0)');
                        }

                        ctx.fillStyle = flameGradient;

                        // LAYER 3: Outer glow (soft, large)
                        ctx.save();
                        ctx.globalAlpha = 0.3;
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = particleSize * 2.0;
                        ctx.beginPath();
                        ctx.ellipse(flickerX, 0, flameWidth * 0.7, flameHeight * 0.6, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.restore();

                        // LAYER 2: Main flame body (organic teardrop shape)
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = particleSize * 1.5;
                        ctx.beginPath();
                        ctx.moveTo(flickerX, -flameHeight / 2);
                        ctx.bezierCurveTo(
                            flameWidth / 2.5 + flickerX * 0.5, -flameHeight / 3,
                            flameWidth / 2, 0,
                            flameWidth / 3, flameHeight / 2
                        );
                        ctx.bezierCurveTo(
                            flameWidth / 6, flameHeight / 2.5,
                            -flameWidth / 6, flameHeight / 2.5,
                            -flameWidth / 3, flameHeight / 2
                        );
                        ctx.bezierCurveTo(
                            -flameWidth / 2, 0,
                            -flameWidth / 2.5 + flickerX * 0.5, -flameHeight / 3,
                            flickerX, -flameHeight / 2
                        );
                        ctx.closePath();
                        ctx.fill();

                        // LAYER 1: Hot core (bright center)
                        ctx.shadowBlur = particleSize * 0.8;
                        const coreGradient = ctx.createRadialGradient(
                            flickerX, flameHeight * 0.2, 0,
                            flickerX, 0, flameHeight * 0.4
                        );
                        coreGradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                        coreGradient.addColorStop(0.5, 'rgba(255, 255, 150, 0.6)');
                        coreGradient.addColorStop(1, 'rgba(255, 200, 0, 0)');
                        ctx.fillStyle = coreGradient;
                        ctx.beginPath();
                        ctx.ellipse(flickerX, 0, flameWidth * 0.3, flameHeight * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    } else {
                        // SMOKE particles (soft circles with blur)
                        ctx.shadowColor = p.color;
                        ctx.shadowBlur = particleSize * 0.8;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, particleSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                    }

                    ctx.restore();

                    if (p.life <= 0) {
                        particles.splice(i, 1);
                    }
                }
                ctx.globalAlpha = 1;
                ctx.filter = 'none';

                // Update and draw explosions during death animation
                updateExplosions();
                drawExplosions();

                deathFrames++;

                // Continue animation if particles or explosions exist, or max frames not reached
                if ((particles.length > 0 || explosions.length > 0) && deathFrames <= maxDeathFrames) {
                    requestAnimationFrame(drawDeathAnimation);
                }
            }

            // Start death animation loop
            requestAnimationFrame(drawDeathAnimation);
        }
    </script>
</body>
</html>
